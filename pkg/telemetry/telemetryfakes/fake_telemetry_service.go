// Code generated by counterfeiter. DO NOT EDIT.
package telemetryfakes

import (
	"context"
	"sync"

	"github.com/livekit/livekit-server/pkg/telemetry"
	"github.com/livekit/protocol/livekit"
)

type FakeTelemetryService struct {
	EgressEndedStub        func(context.Context, *livekit.EgressInfo)
	egressEndedMutex       sync.RWMutex
	egressEndedArgsForCall []struct {
		arg1 context.Context
		arg2 *livekit.EgressInfo
	}
	EgressStartedStub        func(context.Context, *livekit.EgressInfo)
	egressStartedMutex       sync.RWMutex
	egressStartedArgsForCall []struct {
		arg1 context.Context
		arg2 *livekit.EgressInfo
	}
	FlushStatsStub        func()
	flushStatsMutex       sync.RWMutex
	flushStatsArgsForCall []struct {
	}
	NotifyEventStub        func(context.Context, *livekit.WebhookEvent)
	notifyEventMutex       sync.RWMutex
	notifyEventArgsForCall []struct {
		arg1 context.Context
		arg2 *livekit.WebhookEvent
	}
	ParticipantActiveStub        func(context.Context, *livekit.Room, *livekit.ParticipantInfo, *livekit.AnalyticsClientMeta)
	participantActiveMutex       sync.RWMutex
	participantActiveArgsForCall []struct {
		arg1 context.Context
		arg2 *livekit.Room
		arg3 *livekit.ParticipantInfo
		arg4 *livekit.AnalyticsClientMeta
	}
	ParticipantJoinedStub        func(context.Context, *livekit.Room, *livekit.ParticipantInfo, *livekit.ClientInfo, *livekit.AnalyticsClientMeta)
	participantJoinedMutex       sync.RWMutex
	participantJoinedArgsForCall []struct {
		arg1 context.Context
		arg2 *livekit.Room
		arg3 *livekit.ParticipantInfo
		arg4 *livekit.ClientInfo
		arg5 *livekit.AnalyticsClientMeta
	}
	ParticipantLeftStub        func(context.Context, *livekit.Room, *livekit.ParticipantInfo)
	participantLeftMutex       sync.RWMutex
	participantLeftArgsForCall []struct {
		arg1 context.Context
		arg2 *livekit.Room
		arg3 *livekit.ParticipantInfo
	}
	RoomEndedStub        func(context.Context, *livekit.Room)
	roomEndedMutex       sync.RWMutex
	roomEndedArgsForCall []struct {
		arg1 context.Context
		arg2 *livekit.Room
	}
	RoomStartedStub        func(context.Context, *livekit.Room)
	roomStartedMutex       sync.RWMutex
	roomStartedArgsForCall []struct {
		arg1 context.Context
		arg2 *livekit.Room
	}
	SendEventStub        func(context.Context, *livekit.AnalyticsEvent)
	sendEventMutex       sync.RWMutex
	sendEventArgsForCall []struct {
		arg1 context.Context
		arg2 *livekit.AnalyticsEvent
	}
	SendStatsStub        func(context.Context, []*livekit.AnalyticsStat)
	sendStatsMutex       sync.RWMutex
	sendStatsArgsForCall []struct {
		arg1 context.Context
		arg2 []*livekit.AnalyticsStat
	}
	TrackMaxSubscribedVideoQualityStub        func(context.Context, livekit.ParticipantID, *livekit.TrackInfo, string, livekit.VideoQuality)
	trackMaxSubscribedVideoQualityMutex       sync.RWMutex
	trackMaxSubscribedVideoQualityArgsForCall []struct {
		arg1 context.Context
		arg2 livekit.ParticipantID
		arg3 *livekit.TrackInfo
		arg4 string
		arg5 livekit.VideoQuality
	}
	TrackPublishedStub        func(context.Context, livekit.ParticipantID, livekit.ParticipantIdentity, *livekit.TrackInfo)
	trackPublishedMutex       sync.RWMutex
	trackPublishedArgsForCall []struct {
		arg1 context.Context
		arg2 livekit.ParticipantID
		arg3 livekit.ParticipantIdentity
		arg4 *livekit.TrackInfo
	}
	TrackPublishedUpdateStub        func(context.Context, livekit.ParticipantID, *livekit.TrackInfo)
	trackPublishedUpdateMutex       sync.RWMutex
	trackPublishedUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 livekit.ParticipantID
		arg3 *livekit.TrackInfo
	}
	TrackStatsStub        func(livekit.StreamType, livekit.ParticipantID, livekit.TrackID, *livekit.AnalyticsStat)
	trackStatsMutex       sync.RWMutex
	trackStatsArgsForCall []struct {
		arg1 livekit.StreamType
		arg2 livekit.ParticipantID
		arg3 livekit.TrackID
		arg4 *livekit.AnalyticsStat
	}
	TrackSubscribedStub        func(context.Context, livekit.ParticipantID, *livekit.TrackInfo, *livekit.ParticipantInfo)
	trackSubscribedMutex       sync.RWMutex
	trackSubscribedArgsForCall []struct {
		arg1 context.Context
		arg2 livekit.ParticipantID
		arg3 *livekit.TrackInfo
		arg4 *livekit.ParticipantInfo
	}
	TrackUnpublishedStub        func(context.Context, livekit.ParticipantID, livekit.ParticipantIdentity, *livekit.TrackInfo, uint32)
	trackUnpublishedMutex       sync.RWMutex
	trackUnpublishedArgsForCall []struct {
		arg1 context.Context
		arg2 livekit.ParticipantID
		arg3 livekit.ParticipantIdentity
		arg4 *livekit.TrackInfo
		arg5 uint32
	}
	TrackUnsubscribedStub        func(context.Context, livekit.ParticipantID, *livekit.TrackInfo)
	trackUnsubscribedMutex       sync.RWMutex
	trackUnsubscribedArgsForCall []struct {
		arg1 context.Context
		arg2 livekit.ParticipantID
		arg3 *livekit.TrackInfo
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTelemetryService) EgressEnded(arg1 context.Context, arg2 *livekit.EgressInfo) {
	fake.egressEndedMutex.Lock()
	fake.egressEndedArgsForCall = append(fake.egressEndedArgsForCall, struct {
		arg1 context.Context
		arg2 *livekit.EgressInfo
	}{arg1, arg2})
	stub := fake.EgressEndedStub
	fake.recordInvocation("EgressEnded", []interface{}{arg1, arg2})
	fake.egressEndedMutex.Unlock()
	if stub != nil {
		fake.EgressEndedStub(arg1, arg2)
	}
}

func (fake *FakeTelemetryService) EgressEndedCallCount() int {
	fake.egressEndedMutex.RLock()
	defer fake.egressEndedMutex.RUnlock()
	return len(fake.egressEndedArgsForCall)
}

func (fake *FakeTelemetryService) EgressEndedCalls(stub func(context.Context, *livekit.EgressInfo)) {
	fake.egressEndedMutex.Lock()
	defer fake.egressEndedMutex.Unlock()
	fake.EgressEndedStub = stub
}

func (fake *FakeTelemetryService) EgressEndedArgsForCall(i int) (context.Context, *livekit.EgressInfo) {
	fake.egressEndedMutex.RLock()
	defer fake.egressEndedMutex.RUnlock()
	argsForCall := fake.egressEndedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTelemetryService) EgressStarted(arg1 context.Context, arg2 *livekit.EgressInfo) {
	fake.egressStartedMutex.Lock()
	fake.egressStartedArgsForCall = append(fake.egressStartedArgsForCall, struct {
		arg1 context.Context
		arg2 *livekit.EgressInfo
	}{arg1, arg2})
	stub := fake.EgressStartedStub
	fake.recordInvocation("EgressStarted", []interface{}{arg1, arg2})
	fake.egressStartedMutex.Unlock()
	if stub != nil {
		fake.EgressStartedStub(arg1, arg2)
	}
}

func (fake *FakeTelemetryService) EgressStartedCallCount() int {
	fake.egressStartedMutex.RLock()
	defer fake.egressStartedMutex.RUnlock()
	return len(fake.egressStartedArgsForCall)
}

func (fake *FakeTelemetryService) EgressStartedCalls(stub func(context.Context, *livekit.EgressInfo)) {
	fake.egressStartedMutex.Lock()
	defer fake.egressStartedMutex.Unlock()
	fake.EgressStartedStub = stub
}

func (fake *FakeTelemetryService) EgressStartedArgsForCall(i int) (context.Context, *livekit.EgressInfo) {
	fake.egressStartedMutex.RLock()
	defer fake.egressStartedMutex.RUnlock()
	argsForCall := fake.egressStartedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTelemetryService) FlushStats() {
	fake.flushStatsMutex.Lock()
	fake.flushStatsArgsForCall = append(fake.flushStatsArgsForCall, struct {
	}{})
	stub := fake.FlushStatsStub
	fake.recordInvocation("FlushStats", []interface{}{})
	fake.flushStatsMutex.Unlock()
	if stub != nil {
		fake.FlushStatsStub()
	}
}

func (fake *FakeTelemetryService) FlushStatsCallCount() int {
	fake.flushStatsMutex.RLock()
	defer fake.flushStatsMutex.RUnlock()
	return len(fake.flushStatsArgsForCall)
}

func (fake *FakeTelemetryService) FlushStatsCalls(stub func()) {
	fake.flushStatsMutex.Lock()
	defer fake.flushStatsMutex.Unlock()
	fake.FlushStatsStub = stub
}

func (fake *FakeTelemetryService) NotifyEvent(arg1 context.Context, arg2 *livekit.WebhookEvent) {
	fake.notifyEventMutex.Lock()
	fake.notifyEventArgsForCall = append(fake.notifyEventArgsForCall, struct {
		arg1 context.Context
		arg2 *livekit.WebhookEvent
	}{arg1, arg2})
	stub := fake.NotifyEventStub
	fake.recordInvocation("NotifyEvent", []interface{}{arg1, arg2})
	fake.notifyEventMutex.Unlock()
	if stub != nil {
		fake.NotifyEventStub(arg1, arg2)
	}
}

func (fake *FakeTelemetryService) NotifyEventCallCount() int {
	fake.notifyEventMutex.RLock()
	defer fake.notifyEventMutex.RUnlock()
	return len(fake.notifyEventArgsForCall)
}

func (fake *FakeTelemetryService) NotifyEventCalls(stub func(context.Context, *livekit.WebhookEvent)) {
	fake.notifyEventMutex.Lock()
	defer fake.notifyEventMutex.Unlock()
	fake.NotifyEventStub = stub
}

func (fake *FakeTelemetryService) NotifyEventArgsForCall(i int) (context.Context, *livekit.WebhookEvent) {
	fake.notifyEventMutex.RLock()
	defer fake.notifyEventMutex.RUnlock()
	argsForCall := fake.notifyEventArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTelemetryService) ParticipantActive(arg1 context.Context, arg2 *livekit.Room, arg3 *livekit.ParticipantInfo, arg4 *livekit.AnalyticsClientMeta) {
	fake.participantActiveMutex.Lock()
	fake.participantActiveArgsForCall = append(fake.participantActiveArgsForCall, struct {
		arg1 context.Context
		arg2 *livekit.Room
		arg3 *livekit.ParticipantInfo
		arg4 *livekit.AnalyticsClientMeta
	}{arg1, arg2, arg3, arg4})
	stub := fake.ParticipantActiveStub
	fake.recordInvocation("ParticipantActive", []interface{}{arg1, arg2, arg3, arg4})
	fake.participantActiveMutex.Unlock()
	if stub != nil {
		fake.ParticipantActiveStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeTelemetryService) ParticipantActiveCallCount() int {
	fake.participantActiveMutex.RLock()
	defer fake.participantActiveMutex.RUnlock()
	return len(fake.participantActiveArgsForCall)
}

func (fake *FakeTelemetryService) ParticipantActiveCalls(stub func(context.Context, *livekit.Room, *livekit.ParticipantInfo, *livekit.AnalyticsClientMeta)) {
	fake.participantActiveMutex.Lock()
	defer fake.participantActiveMutex.Unlock()
	fake.ParticipantActiveStub = stub
}

func (fake *FakeTelemetryService) ParticipantActiveArgsForCall(i int) (context.Context, *livekit.Room, *livekit.ParticipantInfo, *livekit.AnalyticsClientMeta) {
	fake.participantActiveMutex.RLock()
	defer fake.participantActiveMutex.RUnlock()
	argsForCall := fake.participantActiveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeTelemetryService) ParticipantJoined(arg1 context.Context, arg2 *livekit.Room, arg3 *livekit.ParticipantInfo, arg4 *livekit.ClientInfo, arg5 *livekit.AnalyticsClientMeta) {
	fake.participantJoinedMutex.Lock()
	fake.participantJoinedArgsForCall = append(fake.participantJoinedArgsForCall, struct {
		arg1 context.Context
		arg2 *livekit.Room
		arg3 *livekit.ParticipantInfo
		arg4 *livekit.ClientInfo
		arg5 *livekit.AnalyticsClientMeta
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.ParticipantJoinedStub
	fake.recordInvocation("ParticipantJoined", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.participantJoinedMutex.Unlock()
	if stub != nil {
		fake.ParticipantJoinedStub(arg1, arg2, arg3, arg4, arg5)
	}
}

func (fake *FakeTelemetryService) ParticipantJoinedCallCount() int {
	fake.participantJoinedMutex.RLock()
	defer fake.participantJoinedMutex.RUnlock()
	return len(fake.participantJoinedArgsForCall)
}

func (fake *FakeTelemetryService) ParticipantJoinedCalls(stub func(context.Context, *livekit.Room, *livekit.ParticipantInfo, *livekit.ClientInfo, *livekit.AnalyticsClientMeta)) {
	fake.participantJoinedMutex.Lock()
	defer fake.participantJoinedMutex.Unlock()
	fake.ParticipantJoinedStub = stub
}

func (fake *FakeTelemetryService) ParticipantJoinedArgsForCall(i int) (context.Context, *livekit.Room, *livekit.ParticipantInfo, *livekit.ClientInfo, *livekit.AnalyticsClientMeta) {
	fake.participantJoinedMutex.RLock()
	defer fake.participantJoinedMutex.RUnlock()
	argsForCall := fake.participantJoinedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeTelemetryService) ParticipantLeft(arg1 context.Context, arg2 *livekit.Room, arg3 *livekit.ParticipantInfo) {
	fake.participantLeftMutex.Lock()
	fake.participantLeftArgsForCall = append(fake.participantLeftArgsForCall, struct {
		arg1 context.Context
		arg2 *livekit.Room
		arg3 *livekit.ParticipantInfo
	}{arg1, arg2, arg3})
	stub := fake.ParticipantLeftStub
	fake.recordInvocation("ParticipantLeft", []interface{}{arg1, arg2, arg3})
	fake.participantLeftMutex.Unlock()
	if stub != nil {
		fake.ParticipantLeftStub(arg1, arg2, arg3)
	}
}

func (fake *FakeTelemetryService) ParticipantLeftCallCount() int {
	fake.participantLeftMutex.RLock()
	defer fake.participantLeftMutex.RUnlock()
	return len(fake.participantLeftArgsForCall)
}

func (fake *FakeTelemetryService) ParticipantLeftCalls(stub func(context.Context, *livekit.Room, *livekit.ParticipantInfo)) {
	fake.participantLeftMutex.Lock()
	defer fake.participantLeftMutex.Unlock()
	fake.ParticipantLeftStub = stub
}

func (fake *FakeTelemetryService) ParticipantLeftArgsForCall(i int) (context.Context, *livekit.Room, *livekit.ParticipantInfo) {
	fake.participantLeftMutex.RLock()
	defer fake.participantLeftMutex.RUnlock()
	argsForCall := fake.participantLeftArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTelemetryService) RoomEnded(arg1 context.Context, arg2 *livekit.Room) {
	fake.roomEndedMutex.Lock()
	fake.roomEndedArgsForCall = append(fake.roomEndedArgsForCall, struct {
		arg1 context.Context
		arg2 *livekit.Room
	}{arg1, arg2})
	stub := fake.RoomEndedStub
	fake.recordInvocation("RoomEnded", []interface{}{arg1, arg2})
	fake.roomEndedMutex.Unlock()
	if stub != nil {
		fake.RoomEndedStub(arg1, arg2)
	}
}

func (fake *FakeTelemetryService) RoomEndedCallCount() int {
	fake.roomEndedMutex.RLock()
	defer fake.roomEndedMutex.RUnlock()
	return len(fake.roomEndedArgsForCall)
}

func (fake *FakeTelemetryService) RoomEndedCalls(stub func(context.Context, *livekit.Room)) {
	fake.roomEndedMutex.Lock()
	defer fake.roomEndedMutex.Unlock()
	fake.RoomEndedStub = stub
}

func (fake *FakeTelemetryService) RoomEndedArgsForCall(i int) (context.Context, *livekit.Room) {
	fake.roomEndedMutex.RLock()
	defer fake.roomEndedMutex.RUnlock()
	argsForCall := fake.roomEndedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTelemetryService) RoomStarted(arg1 context.Context, arg2 *livekit.Room) {
	fake.roomStartedMutex.Lock()
	fake.roomStartedArgsForCall = append(fake.roomStartedArgsForCall, struct {
		arg1 context.Context
		arg2 *livekit.Room
	}{arg1, arg2})
	stub := fake.RoomStartedStub
	fake.recordInvocation("RoomStarted", []interface{}{arg1, arg2})
	fake.roomStartedMutex.Unlock()
	if stub != nil {
		fake.RoomStartedStub(arg1, arg2)
	}
}

func (fake *FakeTelemetryService) RoomStartedCallCount() int {
	fake.roomStartedMutex.RLock()
	defer fake.roomStartedMutex.RUnlock()
	return len(fake.roomStartedArgsForCall)
}

func (fake *FakeTelemetryService) RoomStartedCalls(stub func(context.Context, *livekit.Room)) {
	fake.roomStartedMutex.Lock()
	defer fake.roomStartedMutex.Unlock()
	fake.RoomStartedStub = stub
}

func (fake *FakeTelemetryService) RoomStartedArgsForCall(i int) (context.Context, *livekit.Room) {
	fake.roomStartedMutex.RLock()
	defer fake.roomStartedMutex.RUnlock()
	argsForCall := fake.roomStartedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTelemetryService) SendEvent(arg1 context.Context, arg2 *livekit.AnalyticsEvent) {
	fake.sendEventMutex.Lock()
	fake.sendEventArgsForCall = append(fake.sendEventArgsForCall, struct {
		arg1 context.Context
		arg2 *livekit.AnalyticsEvent
	}{arg1, arg2})
	stub := fake.SendEventStub
	fake.recordInvocation("SendEvent", []interface{}{arg1, arg2})
	fake.sendEventMutex.Unlock()
	if stub != nil {
		fake.SendEventStub(arg1, arg2)
	}
}

func (fake *FakeTelemetryService) SendEventCallCount() int {
	fake.sendEventMutex.RLock()
	defer fake.sendEventMutex.RUnlock()
	return len(fake.sendEventArgsForCall)
}

func (fake *FakeTelemetryService) SendEventCalls(stub func(context.Context, *livekit.AnalyticsEvent)) {
	fake.sendEventMutex.Lock()
	defer fake.sendEventMutex.Unlock()
	fake.SendEventStub = stub
}

func (fake *FakeTelemetryService) SendEventArgsForCall(i int) (context.Context, *livekit.AnalyticsEvent) {
	fake.sendEventMutex.RLock()
	defer fake.sendEventMutex.RUnlock()
	argsForCall := fake.sendEventArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTelemetryService) SendStats(arg1 context.Context, arg2 []*livekit.AnalyticsStat) {
	var arg2Copy []*livekit.AnalyticsStat
	if arg2 != nil {
		arg2Copy = make([]*livekit.AnalyticsStat, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.sendStatsMutex.Lock()
	fake.sendStatsArgsForCall = append(fake.sendStatsArgsForCall, struct {
		arg1 context.Context
		arg2 []*livekit.AnalyticsStat
	}{arg1, arg2Copy})
	stub := fake.SendStatsStub
	fake.recordInvocation("SendStats", []interface{}{arg1, arg2Copy})
	fake.sendStatsMutex.Unlock()
	if stub != nil {
		fake.SendStatsStub(arg1, arg2)
	}
}

func (fake *FakeTelemetryService) SendStatsCallCount() int {
	fake.sendStatsMutex.RLock()
	defer fake.sendStatsMutex.RUnlock()
	return len(fake.sendStatsArgsForCall)
}

func (fake *FakeTelemetryService) SendStatsCalls(stub func(context.Context, []*livekit.AnalyticsStat)) {
	fake.sendStatsMutex.Lock()
	defer fake.sendStatsMutex.Unlock()
	fake.SendStatsStub = stub
}

func (fake *FakeTelemetryService) SendStatsArgsForCall(i int) (context.Context, []*livekit.AnalyticsStat) {
	fake.sendStatsMutex.RLock()
	defer fake.sendStatsMutex.RUnlock()
	argsForCall := fake.sendStatsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeTelemetryService) TrackMaxSubscribedVideoQuality(arg1 context.Context, arg2 livekit.ParticipantID, arg3 *livekit.TrackInfo, arg4 string, arg5 livekit.VideoQuality) {
	fake.trackMaxSubscribedVideoQualityMutex.Lock()
	fake.trackMaxSubscribedVideoQualityArgsForCall = append(fake.trackMaxSubscribedVideoQualityArgsForCall, struct {
		arg1 context.Context
		arg2 livekit.ParticipantID
		arg3 *livekit.TrackInfo
		arg4 string
		arg5 livekit.VideoQuality
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.TrackMaxSubscribedVideoQualityStub
	fake.recordInvocation("TrackMaxSubscribedVideoQuality", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.trackMaxSubscribedVideoQualityMutex.Unlock()
	if stub != nil {
		fake.TrackMaxSubscribedVideoQualityStub(arg1, arg2, arg3, arg4, arg5)
	}
}

func (fake *FakeTelemetryService) TrackMaxSubscribedVideoQualityCallCount() int {
	fake.trackMaxSubscribedVideoQualityMutex.RLock()
	defer fake.trackMaxSubscribedVideoQualityMutex.RUnlock()
	return len(fake.trackMaxSubscribedVideoQualityArgsForCall)
}

func (fake *FakeTelemetryService) TrackMaxSubscribedVideoQualityCalls(stub func(context.Context, livekit.ParticipantID, *livekit.TrackInfo, string, livekit.VideoQuality)) {
	fake.trackMaxSubscribedVideoQualityMutex.Lock()
	defer fake.trackMaxSubscribedVideoQualityMutex.Unlock()
	fake.TrackMaxSubscribedVideoQualityStub = stub
}

func (fake *FakeTelemetryService) TrackMaxSubscribedVideoQualityArgsForCall(i int) (context.Context, livekit.ParticipantID, *livekit.TrackInfo, string, livekit.VideoQuality) {
	fake.trackMaxSubscribedVideoQualityMutex.RLock()
	defer fake.trackMaxSubscribedVideoQualityMutex.RUnlock()
	argsForCall := fake.trackMaxSubscribedVideoQualityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeTelemetryService) TrackPublished(arg1 context.Context, arg2 livekit.ParticipantID, arg3 livekit.ParticipantIdentity, arg4 *livekit.TrackInfo) {
	fake.trackPublishedMutex.Lock()
	fake.trackPublishedArgsForCall = append(fake.trackPublishedArgsForCall, struct {
		arg1 context.Context
		arg2 livekit.ParticipantID
		arg3 livekit.ParticipantIdentity
		arg4 *livekit.TrackInfo
	}{arg1, arg2, arg3, arg4})
	stub := fake.TrackPublishedStub
	fake.recordInvocation("TrackPublished", []interface{}{arg1, arg2, arg3, arg4})
	fake.trackPublishedMutex.Unlock()
	if stub != nil {
		fake.TrackPublishedStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeTelemetryService) TrackPublishedCallCount() int {
	fake.trackPublishedMutex.RLock()
	defer fake.trackPublishedMutex.RUnlock()
	return len(fake.trackPublishedArgsForCall)
}

func (fake *FakeTelemetryService) TrackPublishedCalls(stub func(context.Context, livekit.ParticipantID, livekit.ParticipantIdentity, *livekit.TrackInfo)) {
	fake.trackPublishedMutex.Lock()
	defer fake.trackPublishedMutex.Unlock()
	fake.TrackPublishedStub = stub
}

func (fake *FakeTelemetryService) TrackPublishedArgsForCall(i int) (context.Context, livekit.ParticipantID, livekit.ParticipantIdentity, *livekit.TrackInfo) {
	fake.trackPublishedMutex.RLock()
	defer fake.trackPublishedMutex.RUnlock()
	argsForCall := fake.trackPublishedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeTelemetryService) TrackPublishedUpdate(arg1 context.Context, arg2 livekit.ParticipantID, arg3 *livekit.TrackInfo) {
	fake.trackPublishedUpdateMutex.Lock()
	fake.trackPublishedUpdateArgsForCall = append(fake.trackPublishedUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 livekit.ParticipantID
		arg3 *livekit.TrackInfo
	}{arg1, arg2, arg3})
	stub := fake.TrackPublishedUpdateStub
	fake.recordInvocation("TrackPublishedUpdate", []interface{}{arg1, arg2, arg3})
	fake.trackPublishedUpdateMutex.Unlock()
	if stub != nil {
		fake.TrackPublishedUpdateStub(arg1, arg2, arg3)
	}
}

func (fake *FakeTelemetryService) TrackPublishedUpdateCallCount() int {
	fake.trackPublishedUpdateMutex.RLock()
	defer fake.trackPublishedUpdateMutex.RUnlock()
	return len(fake.trackPublishedUpdateArgsForCall)
}

func (fake *FakeTelemetryService) TrackPublishedUpdateCalls(stub func(context.Context, livekit.ParticipantID, *livekit.TrackInfo)) {
	fake.trackPublishedUpdateMutex.Lock()
	defer fake.trackPublishedUpdateMutex.Unlock()
	fake.TrackPublishedUpdateStub = stub
}

func (fake *FakeTelemetryService) TrackPublishedUpdateArgsForCall(i int) (context.Context, livekit.ParticipantID, *livekit.TrackInfo) {
	fake.trackPublishedUpdateMutex.RLock()
	defer fake.trackPublishedUpdateMutex.RUnlock()
	argsForCall := fake.trackPublishedUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTelemetryService) TrackStats(arg1 livekit.StreamType, arg2 livekit.ParticipantID, arg3 livekit.TrackID, arg4 *livekit.AnalyticsStat) {
	fake.trackStatsMutex.Lock()
	fake.trackStatsArgsForCall = append(fake.trackStatsArgsForCall, struct {
		arg1 livekit.StreamType
		arg2 livekit.ParticipantID
		arg3 livekit.TrackID
		arg4 *livekit.AnalyticsStat
	}{arg1, arg2, arg3, arg4})
	stub := fake.TrackStatsStub
	fake.recordInvocation("TrackStats", []interface{}{arg1, arg2, arg3, arg4})
	fake.trackStatsMutex.Unlock()
	if stub != nil {
		fake.TrackStatsStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeTelemetryService) TrackStatsCallCount() int {
	fake.trackStatsMutex.RLock()
	defer fake.trackStatsMutex.RUnlock()
	return len(fake.trackStatsArgsForCall)
}

func (fake *FakeTelemetryService) TrackStatsCalls(stub func(livekit.StreamType, livekit.ParticipantID, livekit.TrackID, *livekit.AnalyticsStat)) {
	fake.trackStatsMutex.Lock()
	defer fake.trackStatsMutex.Unlock()
	fake.TrackStatsStub = stub
}

func (fake *FakeTelemetryService) TrackStatsArgsForCall(i int) (livekit.StreamType, livekit.ParticipantID, livekit.TrackID, *livekit.AnalyticsStat) {
	fake.trackStatsMutex.RLock()
	defer fake.trackStatsMutex.RUnlock()
	argsForCall := fake.trackStatsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeTelemetryService) TrackSubscribed(arg1 context.Context, arg2 livekit.ParticipantID, arg3 *livekit.TrackInfo, arg4 *livekit.ParticipantInfo) {
	fake.trackSubscribedMutex.Lock()
	fake.trackSubscribedArgsForCall = append(fake.trackSubscribedArgsForCall, struct {
		arg1 context.Context
		arg2 livekit.ParticipantID
		arg3 *livekit.TrackInfo
		arg4 *livekit.ParticipantInfo
	}{arg1, arg2, arg3, arg4})
	stub := fake.TrackSubscribedStub
	fake.recordInvocation("TrackSubscribed", []interface{}{arg1, arg2, arg3, arg4})
	fake.trackSubscribedMutex.Unlock()
	if stub != nil {
		fake.TrackSubscribedStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeTelemetryService) TrackSubscribedCallCount() int {
	fake.trackSubscribedMutex.RLock()
	defer fake.trackSubscribedMutex.RUnlock()
	return len(fake.trackSubscribedArgsForCall)
}

func (fake *FakeTelemetryService) TrackSubscribedCalls(stub func(context.Context, livekit.ParticipantID, *livekit.TrackInfo, *livekit.ParticipantInfo)) {
	fake.trackSubscribedMutex.Lock()
	defer fake.trackSubscribedMutex.Unlock()
	fake.TrackSubscribedStub = stub
}

func (fake *FakeTelemetryService) TrackSubscribedArgsForCall(i int) (context.Context, livekit.ParticipantID, *livekit.TrackInfo, *livekit.ParticipantInfo) {
	fake.trackSubscribedMutex.RLock()
	defer fake.trackSubscribedMutex.RUnlock()
	argsForCall := fake.trackSubscribedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeTelemetryService) TrackUnpublished(arg1 context.Context, arg2 livekit.ParticipantID, arg3 livekit.ParticipantIdentity, arg4 *livekit.TrackInfo, arg5 uint32) {
	fake.trackUnpublishedMutex.Lock()
	fake.trackUnpublishedArgsForCall = append(fake.trackUnpublishedArgsForCall, struct {
		arg1 context.Context
		arg2 livekit.ParticipantID
		arg3 livekit.ParticipantIdentity
		arg4 *livekit.TrackInfo
		arg5 uint32
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.TrackUnpublishedStub
	fake.recordInvocation("TrackUnpublished", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.trackUnpublishedMutex.Unlock()
	if stub != nil {
		fake.TrackUnpublishedStub(arg1, arg2, arg3, arg4, arg5)
	}
}

func (fake *FakeTelemetryService) TrackUnpublishedCallCount() int {
	fake.trackUnpublishedMutex.RLock()
	defer fake.trackUnpublishedMutex.RUnlock()
	return len(fake.trackUnpublishedArgsForCall)
}

func (fake *FakeTelemetryService) TrackUnpublishedCalls(stub func(context.Context, livekit.ParticipantID, livekit.ParticipantIdentity, *livekit.TrackInfo, uint32)) {
	fake.trackUnpublishedMutex.Lock()
	defer fake.trackUnpublishedMutex.Unlock()
	fake.TrackUnpublishedStub = stub
}

func (fake *FakeTelemetryService) TrackUnpublishedArgsForCall(i int) (context.Context, livekit.ParticipantID, livekit.ParticipantIdentity, *livekit.TrackInfo, uint32) {
	fake.trackUnpublishedMutex.RLock()
	defer fake.trackUnpublishedMutex.RUnlock()
	argsForCall := fake.trackUnpublishedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeTelemetryService) TrackUnsubscribed(arg1 context.Context, arg2 livekit.ParticipantID, arg3 *livekit.TrackInfo) {
	fake.trackUnsubscribedMutex.Lock()
	fake.trackUnsubscribedArgsForCall = append(fake.trackUnsubscribedArgsForCall, struct {
		arg1 context.Context
		arg2 livekit.ParticipantID
		arg3 *livekit.TrackInfo
	}{arg1, arg2, arg3})
	stub := fake.TrackUnsubscribedStub
	fake.recordInvocation("TrackUnsubscribed", []interface{}{arg1, arg2, arg3})
	fake.trackUnsubscribedMutex.Unlock()
	if stub != nil {
		fake.TrackUnsubscribedStub(arg1, arg2, arg3)
	}
}

func (fake *FakeTelemetryService) TrackUnsubscribedCallCount() int {
	fake.trackUnsubscribedMutex.RLock()
	defer fake.trackUnsubscribedMutex.RUnlock()
	return len(fake.trackUnsubscribedArgsForCall)
}

func (fake *FakeTelemetryService) TrackUnsubscribedCalls(stub func(context.Context, livekit.ParticipantID, *livekit.TrackInfo)) {
	fake.trackUnsubscribedMutex.Lock()
	defer fake.trackUnsubscribedMutex.Unlock()
	fake.TrackUnsubscribedStub = stub
}

func (fake *FakeTelemetryService) TrackUnsubscribedArgsForCall(i int) (context.Context, livekit.ParticipantID, *livekit.TrackInfo) {
	fake.trackUnsubscribedMutex.RLock()
	defer fake.trackUnsubscribedMutex.RUnlock()
	argsForCall := fake.trackUnsubscribedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeTelemetryService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.egressEndedMutex.RLock()
	defer fake.egressEndedMutex.RUnlock()
	fake.egressStartedMutex.RLock()
	defer fake.egressStartedMutex.RUnlock()
	fake.flushStatsMutex.RLock()
	defer fake.flushStatsMutex.RUnlock()
	fake.notifyEventMutex.RLock()
	defer fake.notifyEventMutex.RUnlock()
	fake.participantActiveMutex.RLock()
	defer fake.participantActiveMutex.RUnlock()
	fake.participantJoinedMutex.RLock()
	defer fake.participantJoinedMutex.RUnlock()
	fake.participantLeftMutex.RLock()
	defer fake.participantLeftMutex.RUnlock()
	fake.roomEndedMutex.RLock()
	defer fake.roomEndedMutex.RUnlock()
	fake.roomStartedMutex.RLock()
	defer fake.roomStartedMutex.RUnlock()
	fake.sendEventMutex.RLock()
	defer fake.sendEventMutex.RUnlock()
	fake.sendStatsMutex.RLock()
	defer fake.sendStatsMutex.RUnlock()
	fake.trackMaxSubscribedVideoQualityMutex.RLock()
	defer fake.trackMaxSubscribedVideoQualityMutex.RUnlock()
	fake.trackPublishedMutex.RLock()
	defer fake.trackPublishedMutex.RUnlock()
	fake.trackPublishedUpdateMutex.RLock()
	defer fake.trackPublishedUpdateMutex.RUnlock()
	fake.trackStatsMutex.RLock()
	defer fake.trackStatsMutex.RUnlock()
	fake.trackSubscribedMutex.RLock()
	defer fake.trackSubscribedMutex.RUnlock()
	fake.trackUnpublishedMutex.RLock()
	defer fake.trackUnpublishedMutex.RUnlock()
	fake.trackUnsubscribedMutex.RLock()
	defer fake.trackUnsubscribedMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeTelemetryService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ telemetry.TelemetryService = new(FakeTelemetryService)
