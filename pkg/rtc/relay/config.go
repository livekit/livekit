package relay

import (
	"errors"
	"fmt"
	"math/rand"
	"net"
	"time"

	"github.com/pion/dtls/v2/pkg/crypto/elliptic"
	"github.com/pion/ice/v2"
	"github.com/pion/webrtc/v3"

	"github.com/livekit/livekit-server/pkg/config"
	logging "github.com/livekit/livekit-server/pkg/logger"
	"github.com/livekit/livekit-server/pkg/sfu/buffer"
	"github.com/livekit/livekit-server/pkg/utils"
	"github.com/livekit/protocol/logger"
)

const (
	defaultUDPBufferSize = 16_777_216
)

type WebRTCRelayConfig struct {
	Configuration webrtc.Configuration
	SettingEngine webrtc.SettingEngine
	BufferFactory *buffer.Factory
	RelayUDPMux   ice.UDPMux
	RelayUdpPort  uint32
}

const (
	// number of packets to buffer up
	readBufferSize = 50

	writeBufferSizeInBytes = 4 * 1024 * 1024
)

func NewWebRTCRelayConfig(conf *config.Config, externalIP string) (*WebRTCRelayConfig, error) {
	rtcConf := conf.RTC.Relay
	c := webrtc.Configuration{
		SDPSemantics: webrtc.SDPSemanticsUnifiedPlan,
	}
	s := webrtc.SettingEngine{
		LoggerFactory: logging.NewLoggerFactory(logger.GetLogger()),
	}

	// Change elliptic curve to improve connectivity
	// https://github.com/pion/dtls/pull/474
	s.SetDTLSEllipticCurves(elliptic.P256, elliptic.P384)

	var ifFilter func(string) bool
	if len(conf.RTC.Interfaces.Includes) != 0 || len(conf.RTC.Interfaces.Excludes) != 0 {
		ifFilter = utils.InterfaceFilterFromConf(conf.RTC.Interfaces)
		s.SetInterfaceFilter(ifFilter)
	}

	var ipFilter func(net.IP) bool
	if len(conf.RTC.IPs.Includes) != 0 || len(conf.RTC.IPs.Excludes) != 0 {
		filter, err := utils.IPFilterFromConf(conf.RTC.IPs)
		if err != nil {
			return nil, err
		}
		ipFilter = filter
		s.SetIPFilter(filter)
	}

	if !rtcConf.UseMDNS {
		s.SetICEMulticastDNSMode(ice.MulticastDNSModeDisabled)
	}

	// force it to the node IPs that the user has set
	if externalIP != "" && (conf.RTC.UseExternalIP || (conf.RTC.NodeIP != "" && !conf.RTC.NodeIPAutoGenerated)) {
		if conf.RTC.UseExternalIP {
			ips, err := utils.GetNAT1to1IPsForConf(conf, ipFilter)
			if err != nil {
				return nil, err
			}
			if len(ips) == 0 {
				logger.Infow("no external IPs found, using node IP for NAT1To1Ips", "ip", externalIP)
				s.SetNAT1To1IPs([]string{externalIP}, webrtc.ICECandidateTypeHost)
			} else {
				logger.Infow("using external IPs", "ips", ips)
				s.SetNAT1To1IPs(ips, webrtc.ICECandidateTypeHost)
			}
		} else {
			s.SetNAT1To1IPs([]string{externalIP}, webrtc.ICECandidateTypeHost)
		}
	}

	if rtcConf.PacketBufferSize == 0 {
		rtcConf.PacketBufferSize = 500
	}

	var relayUdpMux ice.UDPMux
	if rtcConf.UdpPort != 0 {
		opts := []ice.UDPMuxFromPortOption{
			ice.UDPMuxFromPortWithReadBufferSize(defaultUDPBufferSize),
			ice.UDPMuxFromPortWithWriteBufferSize(defaultUDPBufferSize),
			ice.UDPMuxFromPortWithLogger(s.LoggerFactory.NewLogger("relay_udp_mux")),
		}
		if rtcConf.EnableLoopbackCandidate {
			opts = append(opts, ice.UDPMuxFromPortWithLoopback())
		}
		if ipFilter != nil {
			opts = append(opts, ice.UDPMuxFromPortWithIPFilter(ipFilter))
		}
		if ifFilter != nil {
			opts = append(opts, ice.UDPMuxFromPortWithInterfaceFilter(ifFilter))
		}

		var err error
		relayUdpMuxFixedPort, err := ice.NewMultiUDPMuxFromPort(int(rtcConf.UdpPort), opts...)
		if err != nil {
			return nil, err
		}
		logger.Infow("using udp mux for relay port", "port", rtcConf.UdpPort)

		r := rand.New(rand.NewSource(time.Now().UnixNano()))
		randomPort := r.Intn(int(rtcConf.PortRangeEnd-rtcConf.PortRangeStart+1)) + int(rtcConf.PortRangeStart)

		relayUdpMuxRandomPort, err := ice.NewMultiUDPMuxFromPort(randomPort, opts...)
		if err != nil {
			return nil, err
		}
		logger.Infow("using udp mux for in-relay additional random port", "port", randomPort)

		relayUdpMux = ice.NewMultiUDPMuxDefault(relayUdpMuxFixedPort, relayUdpMuxRandomPort)
		addresses := relayUdpMux.GetListenAddresses()
		logger.Infow("relay udp mux addresses", "addresses", fmt.Sprintf("%+v", addresses))
	}

	var err error
	networkTypes := make([]webrtc.NetworkType, 0, 4)

	if !rtcConf.ForceTCP {
		networkTypes = append(networkTypes,
			webrtc.NetworkTypeUDP4, webrtc.NetworkTypeUDP6,
		)
		if rtcConf.PortRangeStart != 0 && rtcConf.PortRangeEnd != 0 {
			if err := s.SetEphemeralUDPPortRange(uint16(rtcConf.PortRangeStart), uint16(rtcConf.PortRangeEnd)); err != nil {
				return nil, err
			}
		}
	}

	// use TCP mux when it's set
	var tcpListener *net.TCPListener
	if rtcConf.TCPPort != 0 {
		networkTypes = append(networkTypes,
			webrtc.NetworkTypeTCP4, webrtc.NetworkTypeTCP6,
		)
		tcpListener, err = net.ListenTCP("tcp", &net.TCPAddr{
			Port: int(rtcConf.TCPPort),
		})
		if err != nil {
			return nil, err
		}

		tcpMux := ice.NewTCPMuxDefault(ice.TCPMuxParams{
			Logger:          s.LoggerFactory.NewLogger("tcp_mux"),
			Listener:        tcpListener,
			ReadBufferSize:  readBufferSize,
			WriteBufferSize: writeBufferSizeInBytes,
		})

		s.SetICETCPMux(tcpMux)
	}

	if len(networkTypes) == 0 {
		return nil, errors.New("TCP is forced but not configured")
	}
	s.SetNetworkTypes(networkTypes)

	if rtcConf.EnableLoopbackCandidate {
		s.SetIncludeLoopbackCandidate(true)
	}

	if rtcConf.UseICELite {
		s.SetLite(true)
	} else if conf.RTC.NodeIP == "" && !rtcConf.UseExternalIP {
		// use STUN servers for server to support NAT
		// when deployed in production, we expect UseExternalIP to be used, and ports accessible
		// this is not compatible with ICE Lite
		// Do not automatically add STUN servers if nodeIP is set
		if len(conf.RTC.STUNServers) > 0 {
			c.ICEServers = []webrtc.ICEServer{utils.IceServerForStunServers(conf.RTC.STUNServers)}
		} else {
			c.ICEServers = []webrtc.ICEServer{utils.IceServerForStunServers(config.DefaultStunServers)}
		}
	}

	return &WebRTCRelayConfig{
		Configuration: c,
		SettingEngine: s,
		RelayUDPMux:   relayUdpMux,
		RelayUdpPort:  rtcConf.UdpPort,
	}, nil
}
