// Code generated by counterfeiter. DO NOT EDIT.
package typesfakes

import (
	"sync"

	"github.com/livekit/livekit-server/pkg/rtc/datatrack"
	"github.com/livekit/livekit-server/pkg/rtc/types"
	"github.com/livekit/protocol/livekit"
)

type FakeParticipantListener struct {
	OnDataTrackMessageStub        func(types.Participant, []byte, *datatrack.Packet)
	onDataTrackMessageMutex       sync.RWMutex
	onDataTrackMessageArgsForCall []struct {
		arg1 types.Participant
		arg2 []byte
		arg3 *datatrack.Packet
	}
	OnDataTrackPublishedStub        func(types.Participant, types.DataTrack)
	onDataTrackPublishedMutex       sync.RWMutex
	onDataTrackPublishedArgsForCall []struct {
		arg1 types.Participant
		arg2 types.DataTrack
	}
	OnDataTrackUnpublishedStub        func(types.Participant, types.DataTrack)
	onDataTrackUnpublishedMutex       sync.RWMutex
	onDataTrackUnpublishedArgsForCall []struct {
		arg1 types.Participant
		arg2 types.DataTrack
	}
	OnMetricsStub        func(types.Participant, *livekit.DataPacket)
	onMetricsMutex       sync.RWMutex
	onMetricsArgsForCall []struct {
		arg1 types.Participant
		arg2 *livekit.DataPacket
	}
	OnParticipantUpdateStub        func(types.Participant)
	onParticipantUpdateMutex       sync.RWMutex
	onParticipantUpdateArgsForCall []struct {
		arg1 types.Participant
	}
	OnTrackPublishedStub        func(types.Participant, types.MediaTrack)
	onTrackPublishedMutex       sync.RWMutex
	onTrackPublishedArgsForCall []struct {
		arg1 types.Participant
		arg2 types.MediaTrack
	}
	OnTrackUnpublishedStub        func(types.Participant, types.MediaTrack)
	onTrackUnpublishedMutex       sync.RWMutex
	onTrackUnpublishedArgsForCall []struct {
		arg1 types.Participant
		arg2 types.MediaTrack
	}
	OnTrackUpdatedStub        func(types.Participant, types.MediaTrack)
	onTrackUpdatedMutex       sync.RWMutex
	onTrackUpdatedArgsForCall []struct {
		arg1 types.Participant
		arg2 types.MediaTrack
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeParticipantListener) OnDataTrackMessage(arg1 types.Participant, arg2 []byte, arg3 *datatrack.Packet) {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.onDataTrackMessageMutex.Lock()
	fake.onDataTrackMessageArgsForCall = append(fake.onDataTrackMessageArgsForCall, struct {
		arg1 types.Participant
		arg2 []byte
		arg3 *datatrack.Packet
	}{arg1, arg2Copy, arg3})
	stub := fake.OnDataTrackMessageStub
	fake.recordInvocation("OnDataTrackMessage", []interface{}{arg1, arg2Copy, arg3})
	fake.onDataTrackMessageMutex.Unlock()
	if stub != nil {
		fake.OnDataTrackMessageStub(arg1, arg2, arg3)
	}
}

func (fake *FakeParticipantListener) OnDataTrackMessageCallCount() int {
	fake.onDataTrackMessageMutex.RLock()
	defer fake.onDataTrackMessageMutex.RUnlock()
	return len(fake.onDataTrackMessageArgsForCall)
}

func (fake *FakeParticipantListener) OnDataTrackMessageCalls(stub func(types.Participant, []byte, *datatrack.Packet)) {
	fake.onDataTrackMessageMutex.Lock()
	defer fake.onDataTrackMessageMutex.Unlock()
	fake.OnDataTrackMessageStub = stub
}

func (fake *FakeParticipantListener) OnDataTrackMessageArgsForCall(i int) (types.Participant, []byte, *datatrack.Packet) {
	fake.onDataTrackMessageMutex.RLock()
	defer fake.onDataTrackMessageMutex.RUnlock()
	argsForCall := fake.onDataTrackMessageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeParticipantListener) OnDataTrackPublished(arg1 types.Participant, arg2 types.DataTrack) {
	fake.onDataTrackPublishedMutex.Lock()
	fake.onDataTrackPublishedArgsForCall = append(fake.onDataTrackPublishedArgsForCall, struct {
		arg1 types.Participant
		arg2 types.DataTrack
	}{arg1, arg2})
	stub := fake.OnDataTrackPublishedStub
	fake.recordInvocation("OnDataTrackPublished", []interface{}{arg1, arg2})
	fake.onDataTrackPublishedMutex.Unlock()
	if stub != nil {
		fake.OnDataTrackPublishedStub(arg1, arg2)
	}
}

func (fake *FakeParticipantListener) OnDataTrackPublishedCallCount() int {
	fake.onDataTrackPublishedMutex.RLock()
	defer fake.onDataTrackPublishedMutex.RUnlock()
	return len(fake.onDataTrackPublishedArgsForCall)
}

func (fake *FakeParticipantListener) OnDataTrackPublishedCalls(stub func(types.Participant, types.DataTrack)) {
	fake.onDataTrackPublishedMutex.Lock()
	defer fake.onDataTrackPublishedMutex.Unlock()
	fake.OnDataTrackPublishedStub = stub
}

func (fake *FakeParticipantListener) OnDataTrackPublishedArgsForCall(i int) (types.Participant, types.DataTrack) {
	fake.onDataTrackPublishedMutex.RLock()
	defer fake.onDataTrackPublishedMutex.RUnlock()
	argsForCall := fake.onDataTrackPublishedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeParticipantListener) OnDataTrackUnpublished(arg1 types.Participant, arg2 types.DataTrack) {
	fake.onDataTrackUnpublishedMutex.Lock()
	fake.onDataTrackUnpublishedArgsForCall = append(fake.onDataTrackUnpublishedArgsForCall, struct {
		arg1 types.Participant
		arg2 types.DataTrack
	}{arg1, arg2})
	stub := fake.OnDataTrackUnpublishedStub
	fake.recordInvocation("OnDataTrackUnpublished", []interface{}{arg1, arg2})
	fake.onDataTrackUnpublishedMutex.Unlock()
	if stub != nil {
		fake.OnDataTrackUnpublishedStub(arg1, arg2)
	}
}

func (fake *FakeParticipantListener) OnDataTrackUnpublishedCallCount() int {
	fake.onDataTrackUnpublishedMutex.RLock()
	defer fake.onDataTrackUnpublishedMutex.RUnlock()
	return len(fake.onDataTrackUnpublishedArgsForCall)
}

func (fake *FakeParticipantListener) OnDataTrackUnpublishedCalls(stub func(types.Participant, types.DataTrack)) {
	fake.onDataTrackUnpublishedMutex.Lock()
	defer fake.onDataTrackUnpublishedMutex.Unlock()
	fake.OnDataTrackUnpublishedStub = stub
}

func (fake *FakeParticipantListener) OnDataTrackUnpublishedArgsForCall(i int) (types.Participant, types.DataTrack) {
	fake.onDataTrackUnpublishedMutex.RLock()
	defer fake.onDataTrackUnpublishedMutex.RUnlock()
	argsForCall := fake.onDataTrackUnpublishedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeParticipantListener) OnMetrics(arg1 types.Participant, arg2 *livekit.DataPacket) {
	fake.onMetricsMutex.Lock()
	fake.onMetricsArgsForCall = append(fake.onMetricsArgsForCall, struct {
		arg1 types.Participant
		arg2 *livekit.DataPacket
	}{arg1, arg2})
	stub := fake.OnMetricsStub
	fake.recordInvocation("OnMetrics", []interface{}{arg1, arg2})
	fake.onMetricsMutex.Unlock()
	if stub != nil {
		fake.OnMetricsStub(arg1, arg2)
	}
}

func (fake *FakeParticipantListener) OnMetricsCallCount() int {
	fake.onMetricsMutex.RLock()
	defer fake.onMetricsMutex.RUnlock()
	return len(fake.onMetricsArgsForCall)
}

func (fake *FakeParticipantListener) OnMetricsCalls(stub func(types.Participant, *livekit.DataPacket)) {
	fake.onMetricsMutex.Lock()
	defer fake.onMetricsMutex.Unlock()
	fake.OnMetricsStub = stub
}

func (fake *FakeParticipantListener) OnMetricsArgsForCall(i int) (types.Participant, *livekit.DataPacket) {
	fake.onMetricsMutex.RLock()
	defer fake.onMetricsMutex.RUnlock()
	argsForCall := fake.onMetricsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeParticipantListener) OnParticipantUpdate(arg1 types.Participant) {
	fake.onParticipantUpdateMutex.Lock()
	fake.onParticipantUpdateArgsForCall = append(fake.onParticipantUpdateArgsForCall, struct {
		arg1 types.Participant
	}{arg1})
	stub := fake.OnParticipantUpdateStub
	fake.recordInvocation("OnParticipantUpdate", []interface{}{arg1})
	fake.onParticipantUpdateMutex.Unlock()
	if stub != nil {
		fake.OnParticipantUpdateStub(arg1)
	}
}

func (fake *FakeParticipantListener) OnParticipantUpdateCallCount() int {
	fake.onParticipantUpdateMutex.RLock()
	defer fake.onParticipantUpdateMutex.RUnlock()
	return len(fake.onParticipantUpdateArgsForCall)
}

func (fake *FakeParticipantListener) OnParticipantUpdateCalls(stub func(types.Participant)) {
	fake.onParticipantUpdateMutex.Lock()
	defer fake.onParticipantUpdateMutex.Unlock()
	fake.OnParticipantUpdateStub = stub
}

func (fake *FakeParticipantListener) OnParticipantUpdateArgsForCall(i int) types.Participant {
	fake.onParticipantUpdateMutex.RLock()
	defer fake.onParticipantUpdateMutex.RUnlock()
	argsForCall := fake.onParticipantUpdateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipantListener) OnTrackPublished(arg1 types.Participant, arg2 types.MediaTrack) {
	fake.onTrackPublishedMutex.Lock()
	fake.onTrackPublishedArgsForCall = append(fake.onTrackPublishedArgsForCall, struct {
		arg1 types.Participant
		arg2 types.MediaTrack
	}{arg1, arg2})
	stub := fake.OnTrackPublishedStub
	fake.recordInvocation("OnTrackPublished", []interface{}{arg1, arg2})
	fake.onTrackPublishedMutex.Unlock()
	if stub != nil {
		fake.OnTrackPublishedStub(arg1, arg2)
	}
}

func (fake *FakeParticipantListener) OnTrackPublishedCallCount() int {
	fake.onTrackPublishedMutex.RLock()
	defer fake.onTrackPublishedMutex.RUnlock()
	return len(fake.onTrackPublishedArgsForCall)
}

func (fake *FakeParticipantListener) OnTrackPublishedCalls(stub func(types.Participant, types.MediaTrack)) {
	fake.onTrackPublishedMutex.Lock()
	defer fake.onTrackPublishedMutex.Unlock()
	fake.OnTrackPublishedStub = stub
}

func (fake *FakeParticipantListener) OnTrackPublishedArgsForCall(i int) (types.Participant, types.MediaTrack) {
	fake.onTrackPublishedMutex.RLock()
	defer fake.onTrackPublishedMutex.RUnlock()
	argsForCall := fake.onTrackPublishedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeParticipantListener) OnTrackUnpublished(arg1 types.Participant, arg2 types.MediaTrack) {
	fake.onTrackUnpublishedMutex.Lock()
	fake.onTrackUnpublishedArgsForCall = append(fake.onTrackUnpublishedArgsForCall, struct {
		arg1 types.Participant
		arg2 types.MediaTrack
	}{arg1, arg2})
	stub := fake.OnTrackUnpublishedStub
	fake.recordInvocation("OnTrackUnpublished", []interface{}{arg1, arg2})
	fake.onTrackUnpublishedMutex.Unlock()
	if stub != nil {
		fake.OnTrackUnpublishedStub(arg1, arg2)
	}
}

func (fake *FakeParticipantListener) OnTrackUnpublishedCallCount() int {
	fake.onTrackUnpublishedMutex.RLock()
	defer fake.onTrackUnpublishedMutex.RUnlock()
	return len(fake.onTrackUnpublishedArgsForCall)
}

func (fake *FakeParticipantListener) OnTrackUnpublishedCalls(stub func(types.Participant, types.MediaTrack)) {
	fake.onTrackUnpublishedMutex.Lock()
	defer fake.onTrackUnpublishedMutex.Unlock()
	fake.OnTrackUnpublishedStub = stub
}

func (fake *FakeParticipantListener) OnTrackUnpublishedArgsForCall(i int) (types.Participant, types.MediaTrack) {
	fake.onTrackUnpublishedMutex.RLock()
	defer fake.onTrackUnpublishedMutex.RUnlock()
	argsForCall := fake.onTrackUnpublishedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeParticipantListener) OnTrackUpdated(arg1 types.Participant, arg2 types.MediaTrack) {
	fake.onTrackUpdatedMutex.Lock()
	fake.onTrackUpdatedArgsForCall = append(fake.onTrackUpdatedArgsForCall, struct {
		arg1 types.Participant
		arg2 types.MediaTrack
	}{arg1, arg2})
	stub := fake.OnTrackUpdatedStub
	fake.recordInvocation("OnTrackUpdated", []interface{}{arg1, arg2})
	fake.onTrackUpdatedMutex.Unlock()
	if stub != nil {
		fake.OnTrackUpdatedStub(arg1, arg2)
	}
}

func (fake *FakeParticipantListener) OnTrackUpdatedCallCount() int {
	fake.onTrackUpdatedMutex.RLock()
	defer fake.onTrackUpdatedMutex.RUnlock()
	return len(fake.onTrackUpdatedArgsForCall)
}

func (fake *FakeParticipantListener) OnTrackUpdatedCalls(stub func(types.Participant, types.MediaTrack)) {
	fake.onTrackUpdatedMutex.Lock()
	defer fake.onTrackUpdatedMutex.Unlock()
	fake.OnTrackUpdatedStub = stub
}

func (fake *FakeParticipantListener) OnTrackUpdatedArgsForCall(i int) (types.Participant, types.MediaTrack) {
	fake.onTrackUpdatedMutex.RLock()
	defer fake.onTrackUpdatedMutex.RUnlock()
	argsForCall := fake.onTrackUpdatedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeParticipantListener) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeParticipantListener) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ types.ParticipantListener = new(FakeParticipantListener)
