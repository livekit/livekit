// Code generated by counterfeiter. DO NOT EDIT.
package typesfakes

import (
	"sync"
	"time"

	"github.com/livekit/livekit-server/pkg/routing"
	"github.com/livekit/livekit-server/pkg/rtc/types"
	"github.com/livekit/livekit-server/pkg/sfu"
	"github.com/livekit/protocol/auth"
	"github.com/livekit/protocol/livekit"
	"github.com/livekit/protocol/logger"
	"github.com/pion/rtcp"
	webrtc "github.com/pion/webrtc/v3"
)

type FakeLocalParticipant struct {
	AddICECandidateStub        func(webrtc.ICECandidateInit, livekit.SignalTarget)
	addICECandidateMutex       sync.RWMutex
	addICECandidateArgsForCall []struct {
		arg1 webrtc.ICECandidateInit
		arg2 livekit.SignalTarget
	}
	AddSubscribedTrackStub        func(types.SubscribedTrack)
	addSubscribedTrackMutex       sync.RWMutex
	addSubscribedTrackArgsForCall []struct {
		arg1 types.SubscribedTrack
	}
	AddSubscriberStub        func(types.LocalParticipant, types.AddSubscriberParams) (int, error)
	addSubscriberMutex       sync.RWMutex
	addSubscriberArgsForCall []struct {
		arg1 types.LocalParticipant
		arg2 types.AddSubscriberParams
	}
	addSubscriberReturns struct {
		result1 int
		result2 error
	}
	addSubscriberReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	AddTrackStub        func(*livekit.AddTrackRequest)
	addTrackMutex       sync.RWMutex
	addTrackArgsForCall []struct {
		arg1 *livekit.AddTrackRequest
	}
	AddTrackToSubscriberStub        func(webrtc.TrackLocal, types.AddTrackParams) (*webrtc.RTPSender, *webrtc.RTPTransceiver, error)
	addTrackToSubscriberMutex       sync.RWMutex
	addTrackToSubscriberArgsForCall []struct {
		arg1 webrtc.TrackLocal
		arg2 types.AddTrackParams
	}
	addTrackToSubscriberReturns struct {
		result1 *webrtc.RTPSender
		result2 *webrtc.RTPTransceiver
		result3 error
	}
	addTrackToSubscriberReturnsOnCall map[int]struct {
		result1 *webrtc.RTPSender
		result2 *webrtc.RTPTransceiver
		result3 error
	}
	AddTransceiverFromTrackToSubscriberStub        func(webrtc.TrackLocal, types.AddTrackParams) (*webrtc.RTPSender, *webrtc.RTPTransceiver, error)
	addTransceiverFromTrackToSubscriberMutex       sync.RWMutex
	addTransceiverFromTrackToSubscriberArgsForCall []struct {
		arg1 webrtc.TrackLocal
		arg2 types.AddTrackParams
	}
	addTransceiverFromTrackToSubscriberReturns struct {
		result1 *webrtc.RTPSender
		result2 *webrtc.RTPTransceiver
		result3 error
	}
	addTransceiverFromTrackToSubscriberReturnsOnCall map[int]struct {
		result1 *webrtc.RTPSender
		result2 *webrtc.RTPTransceiver
		result3 error
	}
	CacheDownTrackStub        func(livekit.TrackID, *webrtc.RTPTransceiver, sfu.DownTrackState)
	cacheDownTrackMutex       sync.RWMutex
	cacheDownTrackArgsForCall []struct {
		arg1 livekit.TrackID
		arg2 *webrtc.RTPTransceiver
		arg3 sfu.DownTrackState
	}
	CanPublishStub        func() bool
	canPublishMutex       sync.RWMutex
	canPublishArgsForCall []struct {
	}
	canPublishReturns struct {
		result1 bool
	}
	canPublishReturnsOnCall map[int]struct {
		result1 bool
	}
	CanPublishDataStub        func() bool
	canPublishDataMutex       sync.RWMutex
	canPublishDataArgsForCall []struct {
	}
	canPublishDataReturns struct {
		result1 bool
	}
	canPublishDataReturnsOnCall map[int]struct {
		result1 bool
	}
	CanSubscribeStub        func() bool
	canSubscribeMutex       sync.RWMutex
	canSubscribeArgsForCall []struct {
	}
	canSubscribeReturns struct {
		result1 bool
	}
	canSubscribeReturnsOnCall map[int]struct {
		result1 bool
	}
	ClaimGrantsStub        func() *auth.ClaimGrants
	claimGrantsMutex       sync.RWMutex
	claimGrantsArgsForCall []struct {
	}
	claimGrantsReturns struct {
		result1 *auth.ClaimGrants
	}
	claimGrantsReturnsOnCall map[int]struct {
		result1 *auth.ClaimGrants
	}
	ClearInProgressAndProcessSubscriptionRequestsQueueStub        func(livekit.TrackID)
	clearInProgressAndProcessSubscriptionRequestsQueueMutex       sync.RWMutex
	clearInProgressAndProcessSubscriptionRequestsQueueArgsForCall []struct {
		arg1 livekit.TrackID
	}
	CloseStub        func(bool, types.ParticipantCloseReason) error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
		arg1 bool
		arg2 types.ParticipantCloseReason
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	CloseSignalConnectionStub        func()
	closeSignalConnectionMutex       sync.RWMutex
	closeSignalConnectionArgsForCall []struct {
	}
	ConnectedAtStub        func() time.Time
	connectedAtMutex       sync.RWMutex
	connectedAtArgsForCall []struct {
	}
	connectedAtReturns struct {
		result1 time.Time
	}
	connectedAtReturnsOnCall map[int]struct {
		result1 time.Time
	}
	DebugInfoStub        func() map[string]interface{}
	debugInfoMutex       sync.RWMutex
	debugInfoArgsForCall []struct {
	}
	debugInfoReturns struct {
		result1 map[string]interface{}
	}
	debugInfoReturnsOnCall map[int]struct {
		result1 map[string]interface{}
	}
	EnqueueSubscribeTrackStub        func(livekit.TrackID, bool, func(sub types.LocalParticipant) error)
	enqueueSubscribeTrackMutex       sync.RWMutex
	enqueueSubscribeTrackArgsForCall []struct {
		arg1 livekit.TrackID
		arg2 bool
		arg3 func(sub types.LocalParticipant) error
	}
	EnqueueUnsubscribeTrackStub        func(livekit.TrackID, bool, bool, func(subscriberID livekit.ParticipantID, willBeResumed bool) error)
	enqueueUnsubscribeTrackMutex       sync.RWMutex
	enqueueUnsubscribeTrackArgsForCall []struct {
		arg1 livekit.TrackID
		arg2 bool
		arg3 bool
		arg4 func(subscriberID livekit.ParticipantID, willBeResumed bool) error
	}
	GetAdaptiveStreamStub        func() bool
	getAdaptiveStreamMutex       sync.RWMutex
	getAdaptiveStreamArgsForCall []struct {
	}
	getAdaptiveStreamReturns struct {
		result1 bool
	}
	getAdaptiveStreamReturnsOnCall map[int]struct {
		result1 bool
	}
	GetAudioLevelStub        func() (float64, bool)
	getAudioLevelMutex       sync.RWMutex
	getAudioLevelArgsForCall []struct {
	}
	getAudioLevelReturns struct {
		result1 float64
		result2 bool
	}
	getAudioLevelReturnsOnCall map[int]struct {
		result1 float64
		result2 bool
	}
	GetCachedDownTrackStub        func(livekit.TrackID) (*webrtc.RTPTransceiver, sfu.DownTrackState)
	getCachedDownTrackMutex       sync.RWMutex
	getCachedDownTrackArgsForCall []struct {
		arg1 livekit.TrackID
	}
	getCachedDownTrackReturns struct {
		result1 *webrtc.RTPTransceiver
		result2 sfu.DownTrackState
	}
	getCachedDownTrackReturnsOnCall map[int]struct {
		result1 *webrtc.RTPTransceiver
		result2 sfu.DownTrackState
	}
	GetClientConfigurationStub        func() *livekit.ClientConfiguration
	getClientConfigurationMutex       sync.RWMutex
	getClientConfigurationArgsForCall []struct {
	}
	getClientConfigurationReturns struct {
		result1 *livekit.ClientConfiguration
	}
	getClientConfigurationReturnsOnCall map[int]struct {
		result1 *livekit.ClientConfiguration
	}
	GetConnectionQualityStub        func() *livekit.ConnectionQualityInfo
	getConnectionQualityMutex       sync.RWMutex
	getConnectionQualityArgsForCall []struct {
	}
	getConnectionQualityReturns struct {
		result1 *livekit.ConnectionQualityInfo
	}
	getConnectionQualityReturnsOnCall map[int]struct {
		result1 *livekit.ConnectionQualityInfo
	}
	GetICEConnectionTypeStub        func() types.ICEConnectionType
	getICEConnectionTypeMutex       sync.RWMutex
	getICEConnectionTypeArgsForCall []struct {
	}
	getICEConnectionTypeReturns struct {
		result1 types.ICEConnectionType
	}
	getICEConnectionTypeReturnsOnCall map[int]struct {
		result1 types.ICEConnectionType
	}
	GetLoggerStub        func() logger.Logger
	getLoggerMutex       sync.RWMutex
	getLoggerArgsForCall []struct {
	}
	getLoggerReturns struct {
		result1 logger.Logger
	}
	getLoggerReturnsOnCall map[int]struct {
		result1 logger.Logger
	}
	GetPublishedTrackStub        func(livekit.TrackID) types.MediaTrack
	getPublishedTrackMutex       sync.RWMutex
	getPublishedTrackArgsForCall []struct {
		arg1 livekit.TrackID
	}
	getPublishedTrackReturns struct {
		result1 types.MediaTrack
	}
	getPublishedTrackReturnsOnCall map[int]struct {
		result1 types.MediaTrack
	}
	GetPublishedTracksStub        func() []types.MediaTrack
	getPublishedTracksMutex       sync.RWMutex
	getPublishedTracksArgsForCall []struct {
	}
	getPublishedTracksReturns struct {
		result1 []types.MediaTrack
	}
	getPublishedTracksReturnsOnCall map[int]struct {
		result1 []types.MediaTrack
	}
	GetSubscribedParticipantsStub        func() []livekit.ParticipantID
	getSubscribedParticipantsMutex       sync.RWMutex
	getSubscribedParticipantsArgsForCall []struct {
	}
	getSubscribedParticipantsReturns struct {
		result1 []livekit.ParticipantID
	}
	getSubscribedParticipantsReturnsOnCall map[int]struct {
		result1 []livekit.ParticipantID
	}
	GetSubscribedTracksStub        func() []types.SubscribedTrack
	getSubscribedTracksMutex       sync.RWMutex
	getSubscribedTracksArgsForCall []struct {
	}
	getSubscribedTracksReturns struct {
		result1 []types.SubscribedTrack
	}
	getSubscribedTracksReturnsOnCall map[int]struct {
		result1 []types.SubscribedTrack
	}
	HandleAnswerStub        func(webrtc.SessionDescription)
	handleAnswerMutex       sync.RWMutex
	handleAnswerArgsForCall []struct {
		arg1 webrtc.SessionDescription
	}
	HandleOfferStub        func(webrtc.SessionDescription)
	handleOfferMutex       sync.RWMutex
	handleOfferArgsForCall []struct {
		arg1 webrtc.SessionDescription
	}
	HiddenStub        func() bool
	hiddenMutex       sync.RWMutex
	hiddenArgsForCall []struct {
	}
	hiddenReturns struct {
		result1 bool
	}
	hiddenReturnsOnCall map[int]struct {
		result1 bool
	}
	ICERestartStub        func(*types.IceConfig)
	iCERestartMutex       sync.RWMutex
	iCERestartArgsForCall []struct {
		arg1 *types.IceConfig
	}
	IDStub        func() livekit.ParticipantID
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 livekit.ParticipantID
	}
	iDReturnsOnCall map[int]struct {
		result1 livekit.ParticipantID
	}
	IdentityStub        func() livekit.ParticipantIdentity
	identityMutex       sync.RWMutex
	identityArgsForCall []struct {
	}
	identityReturns struct {
		result1 livekit.ParticipantIdentity
	}
	identityReturnsOnCall map[int]struct {
		result1 livekit.ParticipantIdentity
	}
	IsPublisherStub        func() bool
	isPublisherMutex       sync.RWMutex
	isPublisherArgsForCall []struct {
	}
	isPublisherReturns struct {
		result1 bool
	}
	isPublisherReturnsOnCall map[int]struct {
		result1 bool
	}
	IsReadyStub        func() bool
	isReadyMutex       sync.RWMutex
	isReadyArgsForCall []struct {
	}
	isReadyReturns struct {
		result1 bool
	}
	isReadyReturnsOnCall map[int]struct {
		result1 bool
	}
	IsRecorderStub        func() bool
	isRecorderMutex       sync.RWMutex
	isRecorderArgsForCall []struct {
	}
	isRecorderReturns struct {
		result1 bool
	}
	isRecorderReturnsOnCall map[int]struct {
		result1 bool
	}
	IsSubscribedToStub        func(livekit.ParticipantID) bool
	isSubscribedToMutex       sync.RWMutex
	isSubscribedToArgsForCall []struct {
		arg1 livekit.ParticipantID
	}
	isSubscribedToReturns struct {
		result1 bool
	}
	isSubscribedToReturnsOnCall map[int]struct {
		result1 bool
	}
	MaybeStartMigrationStub        func(bool, func()) bool
	maybeStartMigrationMutex       sync.RWMutex
	maybeStartMigrationArgsForCall []struct {
		arg1 bool
		arg2 func()
	}
	maybeStartMigrationReturns struct {
		result1 bool
	}
	maybeStartMigrationReturnsOnCall map[int]struct {
		result1 bool
	}
	MigrateStateStub        func() types.MigrateState
	migrateStateMutex       sync.RWMutex
	migrateStateArgsForCall []struct {
	}
	migrateStateReturns struct {
		result1 types.MigrateState
	}
	migrateStateReturnsOnCall map[int]struct {
		result1 types.MigrateState
	}
	NegotiateStub        func(bool)
	negotiateMutex       sync.RWMutex
	negotiateArgsForCall []struct {
		arg1 bool
	}
	OnClaimsChangedStub        func(func(types.LocalParticipant))
	onClaimsChangedMutex       sync.RWMutex
	onClaimsChangedArgsForCall []struct {
		arg1 func(types.LocalParticipant)
	}
	OnCloseStub        func(func(types.LocalParticipant, map[livekit.TrackID]livekit.ParticipantID))
	onCloseMutex       sync.RWMutex
	onCloseArgsForCall []struct {
		arg1 func(types.LocalParticipant, map[livekit.TrackID]livekit.ParticipantID)
	}
	OnDataPacketStub        func(func(types.LocalParticipant, *livekit.DataPacket))
	onDataPacketMutex       sync.RWMutex
	onDataPacketArgsForCall []struct {
		arg1 func(types.LocalParticipant, *livekit.DataPacket)
	}
	OnICEConfigChangedStub        func(func(participant types.LocalParticipant, iceConfig types.IceConfig))
	onICEConfigChangedMutex       sync.RWMutex
	onICEConfigChangedArgsForCall []struct {
		arg1 func(participant types.LocalParticipant, iceConfig types.IceConfig)
	}
	OnParticipantUpdateStub        func(func(types.LocalParticipant))
	onParticipantUpdateMutex       sync.RWMutex
	onParticipantUpdateArgsForCall []struct {
		arg1 func(types.LocalParticipant)
	}
	OnReceiverReportStub        func(*sfu.DownTrack, *rtcp.ReceiverReport)
	onReceiverReportMutex       sync.RWMutex
	onReceiverReportArgsForCall []struct {
		arg1 *sfu.DownTrack
		arg2 *rtcp.ReceiverReport
	}
	OnStateChangeStub        func(func(p types.LocalParticipant, oldState livekit.ParticipantInfo_State))
	onStateChangeMutex       sync.RWMutex
	onStateChangeArgsForCall []struct {
		arg1 func(p types.LocalParticipant, oldState livekit.ParticipantInfo_State)
	}
	OnSubscribedToStub        func(func(types.LocalParticipant, livekit.ParticipantID))
	onSubscribedToMutex       sync.RWMutex
	onSubscribedToArgsForCall []struct {
		arg1 func(types.LocalParticipant, livekit.ParticipantID)
	}
	OnTrackPublishedStub        func(func(types.LocalParticipant, types.MediaTrack))
	onTrackPublishedMutex       sync.RWMutex
	onTrackPublishedArgsForCall []struct {
		arg1 func(types.LocalParticipant, types.MediaTrack)
	}
	OnTrackUpdatedStub        func(func(types.LocalParticipant, types.MediaTrack))
	onTrackUpdatedMutex       sync.RWMutex
	onTrackUpdatedArgsForCall []struct {
		arg1 func(types.LocalParticipant, types.MediaTrack)
	}
	ProcessSubscriptionRequestsQueueStub        func(livekit.TrackID)
	processSubscriptionRequestsQueueMutex       sync.RWMutex
	processSubscriptionRequestsQueueArgsForCall []struct {
		arg1 livekit.TrackID
	}
	ProtocolVersionStub        func() types.ProtocolVersion
	protocolVersionMutex       sync.RWMutex
	protocolVersionArgsForCall []struct {
	}
	protocolVersionReturns struct {
		result1 types.ProtocolVersion
	}
	protocolVersionReturnsOnCall map[int]struct {
		result1 types.ProtocolVersion
	}
	RemovePublishedTrackStub        func(types.MediaTrack, bool, bool)
	removePublishedTrackMutex       sync.RWMutex
	removePublishedTrackArgsForCall []struct {
		arg1 types.MediaTrack
		arg2 bool
		arg3 bool
	}
	RemoveSubscribedTrackStub        func(types.SubscribedTrack)
	removeSubscribedTrackMutex       sync.RWMutex
	removeSubscribedTrackArgsForCall []struct {
		arg1 types.SubscribedTrack
	}
	RemoveSubscriberStub        func(types.LocalParticipant, livekit.TrackID, bool)
	removeSubscriberMutex       sync.RWMutex
	removeSubscriberArgsForCall []struct {
		arg1 types.LocalParticipant
		arg2 livekit.TrackID
		arg3 bool
	}
	RemoveTrackFromSubscriberStub        func(*webrtc.RTPSender) error
	removeTrackFromSubscriberMutex       sync.RWMutex
	removeTrackFromSubscriberArgsForCall []struct {
		arg1 *webrtc.RTPSender
	}
	removeTrackFromSubscriberReturns struct {
		result1 error
	}
	removeTrackFromSubscriberReturnsOnCall map[int]struct {
		result1 error
	}
	SendConnectionQualityUpdateStub        func(*livekit.ConnectionQualityUpdate) error
	sendConnectionQualityUpdateMutex       sync.RWMutex
	sendConnectionQualityUpdateArgsForCall []struct {
		arg1 *livekit.ConnectionQualityUpdate
	}
	sendConnectionQualityUpdateReturns struct {
		result1 error
	}
	sendConnectionQualityUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	SendDataPacketStub        func(*livekit.DataPacket) error
	sendDataPacketMutex       sync.RWMutex
	sendDataPacketArgsForCall []struct {
		arg1 *livekit.DataPacket
	}
	sendDataPacketReturns struct {
		result1 error
	}
	sendDataPacketReturnsOnCall map[int]struct {
		result1 error
	}
	SendJoinResponseStub        func(*livekit.JoinResponse) error
	sendJoinResponseMutex       sync.RWMutex
	sendJoinResponseArgsForCall []struct {
		arg1 *livekit.JoinResponse
	}
	sendJoinResponseReturns struct {
		result1 error
	}
	sendJoinResponseReturnsOnCall map[int]struct {
		result1 error
	}
	SendParticipantUpdateStub        func([]*livekit.ParticipantInfo) error
	sendParticipantUpdateMutex       sync.RWMutex
	sendParticipantUpdateArgsForCall []struct {
		arg1 []*livekit.ParticipantInfo
	}
	sendParticipantUpdateReturns struct {
		result1 error
	}
	sendParticipantUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	SendRefreshTokenStub        func(string) error
	sendRefreshTokenMutex       sync.RWMutex
	sendRefreshTokenArgsForCall []struct {
		arg1 string
	}
	sendRefreshTokenReturns struct {
		result1 error
	}
	sendRefreshTokenReturnsOnCall map[int]struct {
		result1 error
	}
	SendRoomUpdateStub        func(*livekit.Room) error
	sendRoomUpdateMutex       sync.RWMutex
	sendRoomUpdateArgsForCall []struct {
		arg1 *livekit.Room
	}
	sendRoomUpdateReturns struct {
		result1 error
	}
	sendRoomUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	SendSpeakerUpdateStub        func([]*livekit.SpeakerInfo) error
	sendSpeakerUpdateMutex       sync.RWMutex
	sendSpeakerUpdateArgsForCall []struct {
		arg1 []*livekit.SpeakerInfo
	}
	sendSpeakerUpdateReturns struct {
		result1 error
	}
	sendSpeakerUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	SetICEConfigStub        func(types.IceConfig)
	setICEConfigMutex       sync.RWMutex
	setICEConfigArgsForCall []struct {
		arg1 types.IceConfig
	}
	SetMetadataStub        func(string)
	setMetadataMutex       sync.RWMutex
	setMetadataArgsForCall []struct {
		arg1 string
	}
	SetMigrateInfoStub        func(*webrtc.SessionDescription, *webrtc.SessionDescription, []*livekit.TrackPublishedResponse, []*livekit.DataChannelInfo)
	setMigrateInfoMutex       sync.RWMutex
	setMigrateInfoArgsForCall []struct {
		arg1 *webrtc.SessionDescription
		arg2 *webrtc.SessionDescription
		arg3 []*livekit.TrackPublishedResponse
		arg4 []*livekit.DataChannelInfo
	}
	SetMigrateStateStub        func(types.MigrateState)
	setMigrateStateMutex       sync.RWMutex
	setMigrateStateArgsForCall []struct {
		arg1 types.MigrateState
	}
	SetPermissionStub        func(*livekit.ParticipantPermission) bool
	setPermissionMutex       sync.RWMutex
	setPermissionArgsForCall []struct {
		arg1 *livekit.ParticipantPermission
	}
	setPermissionReturns struct {
		result1 bool
	}
	setPermissionReturnsOnCall map[int]struct {
		result1 bool
	}
	SetResponseSinkStub        func(routing.MessageSink)
	setResponseSinkMutex       sync.RWMutex
	setResponseSinkArgsForCall []struct {
		arg1 routing.MessageSink
	}
	SetTrackMutedStub        func(livekit.TrackID, bool, bool)
	setTrackMutedMutex       sync.RWMutex
	setTrackMutedArgsForCall []struct {
		arg1 livekit.TrackID
		arg2 bool
		arg3 bool
	}
	StartStub        func()
	startMutex       sync.RWMutex
	startArgsForCall []struct {
	}
	StateStub        func() livekit.ParticipantInfo_State
	stateMutex       sync.RWMutex
	stateArgsForCall []struct {
	}
	stateReturns struct {
		result1 livekit.ParticipantInfo_State
	}
	stateReturnsOnCall map[int]struct {
		result1 livekit.ParticipantInfo_State
	}
	SubscriberAsPrimaryStub        func() bool
	subscriberAsPrimaryMutex       sync.RWMutex
	subscriberAsPrimaryArgsForCall []struct {
	}
	subscriberAsPrimaryReturns struct {
		result1 bool
	}
	subscriberAsPrimaryReturnsOnCall map[int]struct {
		result1 bool
	}
	SubscriptionPermissionStub        func() (*livekit.SubscriptionPermission, *livekit.TimedVersion)
	subscriptionPermissionMutex       sync.RWMutex
	subscriptionPermissionArgsForCall []struct {
	}
	subscriptionPermissionReturns struct {
		result1 *livekit.SubscriptionPermission
		result2 *livekit.TimedVersion
	}
	subscriptionPermissionReturnsOnCall map[int]struct {
		result1 *livekit.SubscriptionPermission
		result2 *livekit.TimedVersion
	}
	SubscriptionPermissionUpdateStub        func(livekit.ParticipantID, livekit.TrackID, bool)
	subscriptionPermissionUpdateMutex       sync.RWMutex
	subscriptionPermissionUpdateArgsForCall []struct {
		arg1 livekit.ParticipantID
		arg2 livekit.TrackID
		arg3 bool
	}
	ToProtoStub        func() *livekit.ParticipantInfo
	toProtoMutex       sync.RWMutex
	toProtoArgsForCall []struct {
	}
	toProtoReturns struct {
		result1 *livekit.ParticipantInfo
	}
	toProtoReturnsOnCall map[int]struct {
		result1 *livekit.ParticipantInfo
	}
	UncacheDownTrackStub        func(*webrtc.RTPTransceiver)
	uncacheDownTrackMutex       sync.RWMutex
	uncacheDownTrackArgsForCall []struct {
		arg1 *webrtc.RTPTransceiver
	}
	UpdateMediaLossStub        func(livekit.NodeID, livekit.TrackID, uint32) error
	updateMediaLossMutex       sync.RWMutex
	updateMediaLossArgsForCall []struct {
		arg1 livekit.NodeID
		arg2 livekit.TrackID
		arg3 uint32
	}
	updateMediaLossReturns struct {
		result1 error
	}
	updateMediaLossReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateRTTStub        func(uint32)
	updateRTTMutex       sync.RWMutex
	updateRTTArgsForCall []struct {
		arg1 uint32
	}
	UpdateSubscribedQualityStub        func(livekit.NodeID, livekit.TrackID, []types.SubscribedCodecQuality) error
	updateSubscribedQualityMutex       sync.RWMutex
	updateSubscribedQualityArgsForCall []struct {
		arg1 livekit.NodeID
		arg2 livekit.TrackID
		arg3 []types.SubscribedCodecQuality
	}
	updateSubscribedQualityReturns struct {
		result1 error
	}
	updateSubscribedQualityReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateSubscribedTrackSettingsStub        func(livekit.TrackID, *livekit.UpdateTrackSettings) error
	updateSubscribedTrackSettingsMutex       sync.RWMutex
	updateSubscribedTrackSettingsArgsForCall []struct {
		arg1 livekit.TrackID
		arg2 *livekit.UpdateTrackSettings
	}
	updateSubscribedTrackSettingsReturns struct {
		result1 error
	}
	updateSubscribedTrackSettingsReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateSubscriptionPermissionStub        func(*livekit.SubscriptionPermission, *livekit.TimedVersion, func(participantIdentity livekit.ParticipantIdentity) types.LocalParticipant, func(participantID livekit.ParticipantID) types.LocalParticipant) error
	updateSubscriptionPermissionMutex       sync.RWMutex
	updateSubscriptionPermissionArgsForCall []struct {
		arg1 *livekit.SubscriptionPermission
		arg2 *livekit.TimedVersion
		arg3 func(participantIdentity livekit.ParticipantIdentity) types.LocalParticipant
		arg4 func(participantID livekit.ParticipantID) types.LocalParticipant
	}
	updateSubscriptionPermissionReturns struct {
		result1 error
	}
	updateSubscriptionPermissionReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateVideoLayersStub        func(*livekit.UpdateVideoLayers) error
	updateVideoLayersMutex       sync.RWMutex
	updateVideoLayersArgsForCall []struct {
		arg1 *livekit.UpdateVideoLayers
	}
	updateVideoLayersReturns struct {
		result1 error
	}
	updateVideoLayersReturnsOnCall map[int]struct {
		result1 error
	}
	VerifySubscribeParticipantInfoStub        func(livekit.ParticipantID, uint32)
	verifySubscribeParticipantInfoMutex       sync.RWMutex
	verifySubscribeParticipantInfoArgsForCall []struct {
		arg1 livekit.ParticipantID
		arg2 uint32
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeLocalParticipant) AddICECandidate(arg1 webrtc.ICECandidateInit, arg2 livekit.SignalTarget) {
	fake.addICECandidateMutex.Lock()
	fake.addICECandidateArgsForCall = append(fake.addICECandidateArgsForCall, struct {
		arg1 webrtc.ICECandidateInit
		arg2 livekit.SignalTarget
	}{arg1, arg2})
	stub := fake.AddICECandidateStub
	fake.recordInvocation("AddICECandidate", []interface{}{arg1, arg2})
	fake.addICECandidateMutex.Unlock()
	if stub != nil {
		fake.AddICECandidateStub(arg1, arg2)
	}
}

func (fake *FakeLocalParticipant) AddICECandidateCallCount() int {
	fake.addICECandidateMutex.RLock()
	defer fake.addICECandidateMutex.RUnlock()
	return len(fake.addICECandidateArgsForCall)
}

func (fake *FakeLocalParticipant) AddICECandidateCalls(stub func(webrtc.ICECandidateInit, livekit.SignalTarget)) {
	fake.addICECandidateMutex.Lock()
	defer fake.addICECandidateMutex.Unlock()
	fake.AddICECandidateStub = stub
}

func (fake *FakeLocalParticipant) AddICECandidateArgsForCall(i int) (webrtc.ICECandidateInit, livekit.SignalTarget) {
	fake.addICECandidateMutex.RLock()
	defer fake.addICECandidateMutex.RUnlock()
	argsForCall := fake.addICECandidateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipant) AddSubscribedTrack(arg1 types.SubscribedTrack) {
	fake.addSubscribedTrackMutex.Lock()
	fake.addSubscribedTrackArgsForCall = append(fake.addSubscribedTrackArgsForCall, struct {
		arg1 types.SubscribedTrack
	}{arg1})
	stub := fake.AddSubscribedTrackStub
	fake.recordInvocation("AddSubscribedTrack", []interface{}{arg1})
	fake.addSubscribedTrackMutex.Unlock()
	if stub != nil {
		fake.AddSubscribedTrackStub(arg1)
	}
}

func (fake *FakeLocalParticipant) AddSubscribedTrackCallCount() int {
	fake.addSubscribedTrackMutex.RLock()
	defer fake.addSubscribedTrackMutex.RUnlock()
	return len(fake.addSubscribedTrackArgsForCall)
}

func (fake *FakeLocalParticipant) AddSubscribedTrackCalls(stub func(types.SubscribedTrack)) {
	fake.addSubscribedTrackMutex.Lock()
	defer fake.addSubscribedTrackMutex.Unlock()
	fake.AddSubscribedTrackStub = stub
}

func (fake *FakeLocalParticipant) AddSubscribedTrackArgsForCall(i int) types.SubscribedTrack {
	fake.addSubscribedTrackMutex.RLock()
	defer fake.addSubscribedTrackMutex.RUnlock()
	argsForCall := fake.addSubscribedTrackArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) AddSubscriber(arg1 types.LocalParticipant, arg2 types.AddSubscriberParams) (int, error) {
	fake.addSubscriberMutex.Lock()
	ret, specificReturn := fake.addSubscriberReturnsOnCall[len(fake.addSubscriberArgsForCall)]
	fake.addSubscriberArgsForCall = append(fake.addSubscriberArgsForCall, struct {
		arg1 types.LocalParticipant
		arg2 types.AddSubscriberParams
	}{arg1, arg2})
	stub := fake.AddSubscriberStub
	fakeReturns := fake.addSubscriberReturns
	fake.recordInvocation("AddSubscriber", []interface{}{arg1, arg2})
	fake.addSubscriberMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeLocalParticipant) AddSubscriberCallCount() int {
	fake.addSubscriberMutex.RLock()
	defer fake.addSubscriberMutex.RUnlock()
	return len(fake.addSubscriberArgsForCall)
}

func (fake *FakeLocalParticipant) AddSubscriberCalls(stub func(types.LocalParticipant, types.AddSubscriberParams) (int, error)) {
	fake.addSubscriberMutex.Lock()
	defer fake.addSubscriberMutex.Unlock()
	fake.AddSubscriberStub = stub
}

func (fake *FakeLocalParticipant) AddSubscriberArgsForCall(i int) (types.LocalParticipant, types.AddSubscriberParams) {
	fake.addSubscriberMutex.RLock()
	defer fake.addSubscriberMutex.RUnlock()
	argsForCall := fake.addSubscriberArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipant) AddSubscriberReturns(result1 int, result2 error) {
	fake.addSubscriberMutex.Lock()
	defer fake.addSubscriberMutex.Unlock()
	fake.AddSubscriberStub = nil
	fake.addSubscriberReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeLocalParticipant) AddSubscriberReturnsOnCall(i int, result1 int, result2 error) {
	fake.addSubscriberMutex.Lock()
	defer fake.addSubscriberMutex.Unlock()
	fake.AddSubscriberStub = nil
	if fake.addSubscriberReturnsOnCall == nil {
		fake.addSubscriberReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.addSubscriberReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeLocalParticipant) AddTrack(arg1 *livekit.AddTrackRequest) {
	fake.addTrackMutex.Lock()
	fake.addTrackArgsForCall = append(fake.addTrackArgsForCall, struct {
		arg1 *livekit.AddTrackRequest
	}{arg1})
	stub := fake.AddTrackStub
	fake.recordInvocation("AddTrack", []interface{}{arg1})
	fake.addTrackMutex.Unlock()
	if stub != nil {
		fake.AddTrackStub(arg1)
	}
}

func (fake *FakeLocalParticipant) AddTrackCallCount() int {
	fake.addTrackMutex.RLock()
	defer fake.addTrackMutex.RUnlock()
	return len(fake.addTrackArgsForCall)
}

func (fake *FakeLocalParticipant) AddTrackCalls(stub func(*livekit.AddTrackRequest)) {
	fake.addTrackMutex.Lock()
	defer fake.addTrackMutex.Unlock()
	fake.AddTrackStub = stub
}

func (fake *FakeLocalParticipant) AddTrackArgsForCall(i int) *livekit.AddTrackRequest {
	fake.addTrackMutex.RLock()
	defer fake.addTrackMutex.RUnlock()
	argsForCall := fake.addTrackArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) AddTrackToSubscriber(arg1 webrtc.TrackLocal, arg2 types.AddTrackParams) (*webrtc.RTPSender, *webrtc.RTPTransceiver, error) {
	fake.addTrackToSubscriberMutex.Lock()
	ret, specificReturn := fake.addTrackToSubscriberReturnsOnCall[len(fake.addTrackToSubscriberArgsForCall)]
	fake.addTrackToSubscriberArgsForCall = append(fake.addTrackToSubscriberArgsForCall, struct {
		arg1 webrtc.TrackLocal
		arg2 types.AddTrackParams
	}{arg1, arg2})
	stub := fake.AddTrackToSubscriberStub
	fakeReturns := fake.addTrackToSubscriberReturns
	fake.recordInvocation("AddTrackToSubscriber", []interface{}{arg1, arg2})
	fake.addTrackToSubscriberMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeLocalParticipant) AddTrackToSubscriberCallCount() int {
	fake.addTrackToSubscriberMutex.RLock()
	defer fake.addTrackToSubscriberMutex.RUnlock()
	return len(fake.addTrackToSubscriberArgsForCall)
}

func (fake *FakeLocalParticipant) AddTrackToSubscriberCalls(stub func(webrtc.TrackLocal, types.AddTrackParams) (*webrtc.RTPSender, *webrtc.RTPTransceiver, error)) {
	fake.addTrackToSubscriberMutex.Lock()
	defer fake.addTrackToSubscriberMutex.Unlock()
	fake.AddTrackToSubscriberStub = stub
}

func (fake *FakeLocalParticipant) AddTrackToSubscriberArgsForCall(i int) (webrtc.TrackLocal, types.AddTrackParams) {
	fake.addTrackToSubscriberMutex.RLock()
	defer fake.addTrackToSubscriberMutex.RUnlock()
	argsForCall := fake.addTrackToSubscriberArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipant) AddTrackToSubscriberReturns(result1 *webrtc.RTPSender, result2 *webrtc.RTPTransceiver, result3 error) {
	fake.addTrackToSubscriberMutex.Lock()
	defer fake.addTrackToSubscriberMutex.Unlock()
	fake.AddTrackToSubscriberStub = nil
	fake.addTrackToSubscriberReturns = struct {
		result1 *webrtc.RTPSender
		result2 *webrtc.RTPTransceiver
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeLocalParticipant) AddTrackToSubscriberReturnsOnCall(i int, result1 *webrtc.RTPSender, result2 *webrtc.RTPTransceiver, result3 error) {
	fake.addTrackToSubscriberMutex.Lock()
	defer fake.addTrackToSubscriberMutex.Unlock()
	fake.AddTrackToSubscriberStub = nil
	if fake.addTrackToSubscriberReturnsOnCall == nil {
		fake.addTrackToSubscriberReturnsOnCall = make(map[int]struct {
			result1 *webrtc.RTPSender
			result2 *webrtc.RTPTransceiver
			result3 error
		})
	}
	fake.addTrackToSubscriberReturnsOnCall[i] = struct {
		result1 *webrtc.RTPSender
		result2 *webrtc.RTPTransceiver
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeLocalParticipant) AddTransceiverFromTrackToSubscriber(arg1 webrtc.TrackLocal, arg2 types.AddTrackParams) (*webrtc.RTPSender, *webrtc.RTPTransceiver, error) {
	fake.addTransceiverFromTrackToSubscriberMutex.Lock()
	ret, specificReturn := fake.addTransceiverFromTrackToSubscriberReturnsOnCall[len(fake.addTransceiverFromTrackToSubscriberArgsForCall)]
	fake.addTransceiverFromTrackToSubscriberArgsForCall = append(fake.addTransceiverFromTrackToSubscriberArgsForCall, struct {
		arg1 webrtc.TrackLocal
		arg2 types.AddTrackParams
	}{arg1, arg2})
	stub := fake.AddTransceiverFromTrackToSubscriberStub
	fakeReturns := fake.addTransceiverFromTrackToSubscriberReturns
	fake.recordInvocation("AddTransceiverFromTrackToSubscriber", []interface{}{arg1, arg2})
	fake.addTransceiverFromTrackToSubscriberMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeLocalParticipant) AddTransceiverFromTrackToSubscriberCallCount() int {
	fake.addTransceiverFromTrackToSubscriberMutex.RLock()
	defer fake.addTransceiverFromTrackToSubscriberMutex.RUnlock()
	return len(fake.addTransceiverFromTrackToSubscriberArgsForCall)
}

func (fake *FakeLocalParticipant) AddTransceiverFromTrackToSubscriberCalls(stub func(webrtc.TrackLocal, types.AddTrackParams) (*webrtc.RTPSender, *webrtc.RTPTransceiver, error)) {
	fake.addTransceiverFromTrackToSubscriberMutex.Lock()
	defer fake.addTransceiverFromTrackToSubscriberMutex.Unlock()
	fake.AddTransceiverFromTrackToSubscriberStub = stub
}

func (fake *FakeLocalParticipant) AddTransceiverFromTrackToSubscriberArgsForCall(i int) (webrtc.TrackLocal, types.AddTrackParams) {
	fake.addTransceiverFromTrackToSubscriberMutex.RLock()
	defer fake.addTransceiverFromTrackToSubscriberMutex.RUnlock()
	argsForCall := fake.addTransceiverFromTrackToSubscriberArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipant) AddTransceiverFromTrackToSubscriberReturns(result1 *webrtc.RTPSender, result2 *webrtc.RTPTransceiver, result3 error) {
	fake.addTransceiverFromTrackToSubscriberMutex.Lock()
	defer fake.addTransceiverFromTrackToSubscriberMutex.Unlock()
	fake.AddTransceiverFromTrackToSubscriberStub = nil
	fake.addTransceiverFromTrackToSubscriberReturns = struct {
		result1 *webrtc.RTPSender
		result2 *webrtc.RTPTransceiver
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeLocalParticipant) AddTransceiverFromTrackToSubscriberReturnsOnCall(i int, result1 *webrtc.RTPSender, result2 *webrtc.RTPTransceiver, result3 error) {
	fake.addTransceiverFromTrackToSubscriberMutex.Lock()
	defer fake.addTransceiverFromTrackToSubscriberMutex.Unlock()
	fake.AddTransceiverFromTrackToSubscriberStub = nil
	if fake.addTransceiverFromTrackToSubscriberReturnsOnCall == nil {
		fake.addTransceiverFromTrackToSubscriberReturnsOnCall = make(map[int]struct {
			result1 *webrtc.RTPSender
			result2 *webrtc.RTPTransceiver
			result3 error
		})
	}
	fake.addTransceiverFromTrackToSubscriberReturnsOnCall[i] = struct {
		result1 *webrtc.RTPSender
		result2 *webrtc.RTPTransceiver
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeLocalParticipant) CacheDownTrack(arg1 livekit.TrackID, arg2 *webrtc.RTPTransceiver, arg3 sfu.DownTrackState) {
	fake.cacheDownTrackMutex.Lock()
	fake.cacheDownTrackArgsForCall = append(fake.cacheDownTrackArgsForCall, struct {
		arg1 livekit.TrackID
		arg2 *webrtc.RTPTransceiver
		arg3 sfu.DownTrackState
	}{arg1, arg2, arg3})
	stub := fake.CacheDownTrackStub
	fake.recordInvocation("CacheDownTrack", []interface{}{arg1, arg2, arg3})
	fake.cacheDownTrackMutex.Unlock()
	if stub != nil {
		fake.CacheDownTrackStub(arg1, arg2, arg3)
	}
}

func (fake *FakeLocalParticipant) CacheDownTrackCallCount() int {
	fake.cacheDownTrackMutex.RLock()
	defer fake.cacheDownTrackMutex.RUnlock()
	return len(fake.cacheDownTrackArgsForCall)
}

func (fake *FakeLocalParticipant) CacheDownTrackCalls(stub func(livekit.TrackID, *webrtc.RTPTransceiver, sfu.DownTrackState)) {
	fake.cacheDownTrackMutex.Lock()
	defer fake.cacheDownTrackMutex.Unlock()
	fake.CacheDownTrackStub = stub
}

func (fake *FakeLocalParticipant) CacheDownTrackArgsForCall(i int) (livekit.TrackID, *webrtc.RTPTransceiver, sfu.DownTrackState) {
	fake.cacheDownTrackMutex.RLock()
	defer fake.cacheDownTrackMutex.RUnlock()
	argsForCall := fake.cacheDownTrackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLocalParticipant) CanPublish() bool {
	fake.canPublishMutex.Lock()
	ret, specificReturn := fake.canPublishReturnsOnCall[len(fake.canPublishArgsForCall)]
	fake.canPublishArgsForCall = append(fake.canPublishArgsForCall, struct {
	}{})
	stub := fake.CanPublishStub
	fakeReturns := fake.canPublishReturns
	fake.recordInvocation("CanPublish", []interface{}{})
	fake.canPublishMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) CanPublishCallCount() int {
	fake.canPublishMutex.RLock()
	defer fake.canPublishMutex.RUnlock()
	return len(fake.canPublishArgsForCall)
}

func (fake *FakeLocalParticipant) CanPublishCalls(stub func() bool) {
	fake.canPublishMutex.Lock()
	defer fake.canPublishMutex.Unlock()
	fake.CanPublishStub = stub
}

func (fake *FakeLocalParticipant) CanPublishReturns(result1 bool) {
	fake.canPublishMutex.Lock()
	defer fake.canPublishMutex.Unlock()
	fake.CanPublishStub = nil
	fake.canPublishReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) CanPublishReturnsOnCall(i int, result1 bool) {
	fake.canPublishMutex.Lock()
	defer fake.canPublishMutex.Unlock()
	fake.CanPublishStub = nil
	if fake.canPublishReturnsOnCall == nil {
		fake.canPublishReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.canPublishReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) CanPublishData() bool {
	fake.canPublishDataMutex.Lock()
	ret, specificReturn := fake.canPublishDataReturnsOnCall[len(fake.canPublishDataArgsForCall)]
	fake.canPublishDataArgsForCall = append(fake.canPublishDataArgsForCall, struct {
	}{})
	stub := fake.CanPublishDataStub
	fakeReturns := fake.canPublishDataReturns
	fake.recordInvocation("CanPublishData", []interface{}{})
	fake.canPublishDataMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) CanPublishDataCallCount() int {
	fake.canPublishDataMutex.RLock()
	defer fake.canPublishDataMutex.RUnlock()
	return len(fake.canPublishDataArgsForCall)
}

func (fake *FakeLocalParticipant) CanPublishDataCalls(stub func() bool) {
	fake.canPublishDataMutex.Lock()
	defer fake.canPublishDataMutex.Unlock()
	fake.CanPublishDataStub = stub
}

func (fake *FakeLocalParticipant) CanPublishDataReturns(result1 bool) {
	fake.canPublishDataMutex.Lock()
	defer fake.canPublishDataMutex.Unlock()
	fake.CanPublishDataStub = nil
	fake.canPublishDataReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) CanPublishDataReturnsOnCall(i int, result1 bool) {
	fake.canPublishDataMutex.Lock()
	defer fake.canPublishDataMutex.Unlock()
	fake.CanPublishDataStub = nil
	if fake.canPublishDataReturnsOnCall == nil {
		fake.canPublishDataReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.canPublishDataReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) CanSubscribe() bool {
	fake.canSubscribeMutex.Lock()
	ret, specificReturn := fake.canSubscribeReturnsOnCall[len(fake.canSubscribeArgsForCall)]
	fake.canSubscribeArgsForCall = append(fake.canSubscribeArgsForCall, struct {
	}{})
	stub := fake.CanSubscribeStub
	fakeReturns := fake.canSubscribeReturns
	fake.recordInvocation("CanSubscribe", []interface{}{})
	fake.canSubscribeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) CanSubscribeCallCount() int {
	fake.canSubscribeMutex.RLock()
	defer fake.canSubscribeMutex.RUnlock()
	return len(fake.canSubscribeArgsForCall)
}

func (fake *FakeLocalParticipant) CanSubscribeCalls(stub func() bool) {
	fake.canSubscribeMutex.Lock()
	defer fake.canSubscribeMutex.Unlock()
	fake.CanSubscribeStub = stub
}

func (fake *FakeLocalParticipant) CanSubscribeReturns(result1 bool) {
	fake.canSubscribeMutex.Lock()
	defer fake.canSubscribeMutex.Unlock()
	fake.CanSubscribeStub = nil
	fake.canSubscribeReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) CanSubscribeReturnsOnCall(i int, result1 bool) {
	fake.canSubscribeMutex.Lock()
	defer fake.canSubscribeMutex.Unlock()
	fake.CanSubscribeStub = nil
	if fake.canSubscribeReturnsOnCall == nil {
		fake.canSubscribeReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.canSubscribeReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) ClaimGrants() *auth.ClaimGrants {
	fake.claimGrantsMutex.Lock()
	ret, specificReturn := fake.claimGrantsReturnsOnCall[len(fake.claimGrantsArgsForCall)]
	fake.claimGrantsArgsForCall = append(fake.claimGrantsArgsForCall, struct {
	}{})
	stub := fake.ClaimGrantsStub
	fakeReturns := fake.claimGrantsReturns
	fake.recordInvocation("ClaimGrants", []interface{}{})
	fake.claimGrantsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) ClaimGrantsCallCount() int {
	fake.claimGrantsMutex.RLock()
	defer fake.claimGrantsMutex.RUnlock()
	return len(fake.claimGrantsArgsForCall)
}

func (fake *FakeLocalParticipant) ClaimGrantsCalls(stub func() *auth.ClaimGrants) {
	fake.claimGrantsMutex.Lock()
	defer fake.claimGrantsMutex.Unlock()
	fake.ClaimGrantsStub = stub
}

func (fake *FakeLocalParticipant) ClaimGrantsReturns(result1 *auth.ClaimGrants) {
	fake.claimGrantsMutex.Lock()
	defer fake.claimGrantsMutex.Unlock()
	fake.ClaimGrantsStub = nil
	fake.claimGrantsReturns = struct {
		result1 *auth.ClaimGrants
	}{result1}
}

func (fake *FakeLocalParticipant) ClaimGrantsReturnsOnCall(i int, result1 *auth.ClaimGrants) {
	fake.claimGrantsMutex.Lock()
	defer fake.claimGrantsMutex.Unlock()
	fake.ClaimGrantsStub = nil
	if fake.claimGrantsReturnsOnCall == nil {
		fake.claimGrantsReturnsOnCall = make(map[int]struct {
			result1 *auth.ClaimGrants
		})
	}
	fake.claimGrantsReturnsOnCall[i] = struct {
		result1 *auth.ClaimGrants
	}{result1}
}

func (fake *FakeLocalParticipant) ClearInProgressAndProcessSubscriptionRequestsQueue(arg1 livekit.TrackID) {
	fake.clearInProgressAndProcessSubscriptionRequestsQueueMutex.Lock()
	fake.clearInProgressAndProcessSubscriptionRequestsQueueArgsForCall = append(fake.clearInProgressAndProcessSubscriptionRequestsQueueArgsForCall, struct {
		arg1 livekit.TrackID
	}{arg1})
	stub := fake.ClearInProgressAndProcessSubscriptionRequestsQueueStub
	fake.recordInvocation("ClearInProgressAndProcessSubscriptionRequestsQueue", []interface{}{arg1})
	fake.clearInProgressAndProcessSubscriptionRequestsQueueMutex.Unlock()
	if stub != nil {
		fake.ClearInProgressAndProcessSubscriptionRequestsQueueStub(arg1)
	}
}

func (fake *FakeLocalParticipant) ClearInProgressAndProcessSubscriptionRequestsQueueCallCount() int {
	fake.clearInProgressAndProcessSubscriptionRequestsQueueMutex.RLock()
	defer fake.clearInProgressAndProcessSubscriptionRequestsQueueMutex.RUnlock()
	return len(fake.clearInProgressAndProcessSubscriptionRequestsQueueArgsForCall)
}

func (fake *FakeLocalParticipant) ClearInProgressAndProcessSubscriptionRequestsQueueCalls(stub func(livekit.TrackID)) {
	fake.clearInProgressAndProcessSubscriptionRequestsQueueMutex.Lock()
	defer fake.clearInProgressAndProcessSubscriptionRequestsQueueMutex.Unlock()
	fake.ClearInProgressAndProcessSubscriptionRequestsQueueStub = stub
}

func (fake *FakeLocalParticipant) ClearInProgressAndProcessSubscriptionRequestsQueueArgsForCall(i int) livekit.TrackID {
	fake.clearInProgressAndProcessSubscriptionRequestsQueueMutex.RLock()
	defer fake.clearInProgressAndProcessSubscriptionRequestsQueueMutex.RUnlock()
	argsForCall := fake.clearInProgressAndProcessSubscriptionRequestsQueueArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) Close(arg1 bool, arg2 types.ParticipantCloseReason) error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
		arg1 bool
		arg2 types.ParticipantCloseReason
	}{arg1, arg2})
	stub := fake.CloseStub
	fakeReturns := fake.closeReturns
	fake.recordInvocation("Close", []interface{}{arg1, arg2})
	fake.closeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeLocalParticipant) CloseCalls(stub func(bool, types.ParticipantCloseReason) error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeLocalParticipant) CloseArgsForCall(i int) (bool, types.ParticipantCloseReason) {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	argsForCall := fake.closeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipant) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) CloseSignalConnection() {
	fake.closeSignalConnectionMutex.Lock()
	fake.closeSignalConnectionArgsForCall = append(fake.closeSignalConnectionArgsForCall, struct {
	}{})
	stub := fake.CloseSignalConnectionStub
	fake.recordInvocation("CloseSignalConnection", []interface{}{})
	fake.closeSignalConnectionMutex.Unlock()
	if stub != nil {
		fake.CloseSignalConnectionStub()
	}
}

func (fake *FakeLocalParticipant) CloseSignalConnectionCallCount() int {
	fake.closeSignalConnectionMutex.RLock()
	defer fake.closeSignalConnectionMutex.RUnlock()
	return len(fake.closeSignalConnectionArgsForCall)
}

func (fake *FakeLocalParticipant) CloseSignalConnectionCalls(stub func()) {
	fake.closeSignalConnectionMutex.Lock()
	defer fake.closeSignalConnectionMutex.Unlock()
	fake.CloseSignalConnectionStub = stub
}

func (fake *FakeLocalParticipant) ConnectedAt() time.Time {
	fake.connectedAtMutex.Lock()
	ret, specificReturn := fake.connectedAtReturnsOnCall[len(fake.connectedAtArgsForCall)]
	fake.connectedAtArgsForCall = append(fake.connectedAtArgsForCall, struct {
	}{})
	stub := fake.ConnectedAtStub
	fakeReturns := fake.connectedAtReturns
	fake.recordInvocation("ConnectedAt", []interface{}{})
	fake.connectedAtMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) ConnectedAtCallCount() int {
	fake.connectedAtMutex.RLock()
	defer fake.connectedAtMutex.RUnlock()
	return len(fake.connectedAtArgsForCall)
}

func (fake *FakeLocalParticipant) ConnectedAtCalls(stub func() time.Time) {
	fake.connectedAtMutex.Lock()
	defer fake.connectedAtMutex.Unlock()
	fake.ConnectedAtStub = stub
}

func (fake *FakeLocalParticipant) ConnectedAtReturns(result1 time.Time) {
	fake.connectedAtMutex.Lock()
	defer fake.connectedAtMutex.Unlock()
	fake.ConnectedAtStub = nil
	fake.connectedAtReturns = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeLocalParticipant) ConnectedAtReturnsOnCall(i int, result1 time.Time) {
	fake.connectedAtMutex.Lock()
	defer fake.connectedAtMutex.Unlock()
	fake.ConnectedAtStub = nil
	if fake.connectedAtReturnsOnCall == nil {
		fake.connectedAtReturnsOnCall = make(map[int]struct {
			result1 time.Time
		})
	}
	fake.connectedAtReturnsOnCall[i] = struct {
		result1 time.Time
	}{result1}
}

func (fake *FakeLocalParticipant) DebugInfo() map[string]interface{} {
	fake.debugInfoMutex.Lock()
	ret, specificReturn := fake.debugInfoReturnsOnCall[len(fake.debugInfoArgsForCall)]
	fake.debugInfoArgsForCall = append(fake.debugInfoArgsForCall, struct {
	}{})
	stub := fake.DebugInfoStub
	fakeReturns := fake.debugInfoReturns
	fake.recordInvocation("DebugInfo", []interface{}{})
	fake.debugInfoMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) DebugInfoCallCount() int {
	fake.debugInfoMutex.RLock()
	defer fake.debugInfoMutex.RUnlock()
	return len(fake.debugInfoArgsForCall)
}

func (fake *FakeLocalParticipant) DebugInfoCalls(stub func() map[string]interface{}) {
	fake.debugInfoMutex.Lock()
	defer fake.debugInfoMutex.Unlock()
	fake.DebugInfoStub = stub
}

func (fake *FakeLocalParticipant) DebugInfoReturns(result1 map[string]interface{}) {
	fake.debugInfoMutex.Lock()
	defer fake.debugInfoMutex.Unlock()
	fake.DebugInfoStub = nil
	fake.debugInfoReturns = struct {
		result1 map[string]interface{}
	}{result1}
}

func (fake *FakeLocalParticipant) DebugInfoReturnsOnCall(i int, result1 map[string]interface{}) {
	fake.debugInfoMutex.Lock()
	defer fake.debugInfoMutex.Unlock()
	fake.DebugInfoStub = nil
	if fake.debugInfoReturnsOnCall == nil {
		fake.debugInfoReturnsOnCall = make(map[int]struct {
			result1 map[string]interface{}
		})
	}
	fake.debugInfoReturnsOnCall[i] = struct {
		result1 map[string]interface{}
	}{result1}
}

func (fake *FakeLocalParticipant) EnqueueSubscribeTrack(arg1 livekit.TrackID, arg2 bool, arg3 func(sub types.LocalParticipant) error) {
	fake.enqueueSubscribeTrackMutex.Lock()
	fake.enqueueSubscribeTrackArgsForCall = append(fake.enqueueSubscribeTrackArgsForCall, struct {
		arg1 livekit.TrackID
		arg2 bool
		arg3 func(sub types.LocalParticipant) error
	}{arg1, arg2, arg3})
	stub := fake.EnqueueSubscribeTrackStub
	fake.recordInvocation("EnqueueSubscribeTrack", []interface{}{arg1, arg2, arg3})
	fake.enqueueSubscribeTrackMutex.Unlock()
	if stub != nil {
		fake.EnqueueSubscribeTrackStub(arg1, arg2, arg3)
	}
}

func (fake *FakeLocalParticipant) EnqueueSubscribeTrackCallCount() int {
	fake.enqueueSubscribeTrackMutex.RLock()
	defer fake.enqueueSubscribeTrackMutex.RUnlock()
	return len(fake.enqueueSubscribeTrackArgsForCall)
}

func (fake *FakeLocalParticipant) EnqueueSubscribeTrackCalls(stub func(livekit.TrackID, bool, func(sub types.LocalParticipant) error)) {
	fake.enqueueSubscribeTrackMutex.Lock()
	defer fake.enqueueSubscribeTrackMutex.Unlock()
	fake.EnqueueSubscribeTrackStub = stub
}

func (fake *FakeLocalParticipant) EnqueueSubscribeTrackArgsForCall(i int) (livekit.TrackID, bool, func(sub types.LocalParticipant) error) {
	fake.enqueueSubscribeTrackMutex.RLock()
	defer fake.enqueueSubscribeTrackMutex.RUnlock()
	argsForCall := fake.enqueueSubscribeTrackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLocalParticipant) EnqueueUnsubscribeTrack(arg1 livekit.TrackID, arg2 bool, arg3 bool, arg4 func(subscriberID livekit.ParticipantID, willBeResumed bool) error) {
	fake.enqueueUnsubscribeTrackMutex.Lock()
	fake.enqueueUnsubscribeTrackArgsForCall = append(fake.enqueueUnsubscribeTrackArgsForCall, struct {
		arg1 livekit.TrackID
		arg2 bool
		arg3 bool
		arg4 func(subscriberID livekit.ParticipantID, willBeResumed bool) error
	}{arg1, arg2, arg3, arg4})
	stub := fake.EnqueueUnsubscribeTrackStub
	fake.recordInvocation("EnqueueUnsubscribeTrack", []interface{}{arg1, arg2, arg3, arg4})
	fake.enqueueUnsubscribeTrackMutex.Unlock()
	if stub != nil {
		fake.EnqueueUnsubscribeTrackStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeLocalParticipant) EnqueueUnsubscribeTrackCallCount() int {
	fake.enqueueUnsubscribeTrackMutex.RLock()
	defer fake.enqueueUnsubscribeTrackMutex.RUnlock()
	return len(fake.enqueueUnsubscribeTrackArgsForCall)
}

func (fake *FakeLocalParticipant) EnqueueUnsubscribeTrackCalls(stub func(livekit.TrackID, bool, bool, func(subscriberID livekit.ParticipantID, willBeResumed bool) error)) {
	fake.enqueueUnsubscribeTrackMutex.Lock()
	defer fake.enqueueUnsubscribeTrackMutex.Unlock()
	fake.EnqueueUnsubscribeTrackStub = stub
}

func (fake *FakeLocalParticipant) EnqueueUnsubscribeTrackArgsForCall(i int) (livekit.TrackID, bool, bool, func(subscriberID livekit.ParticipantID, willBeResumed bool) error) {
	fake.enqueueUnsubscribeTrackMutex.RLock()
	defer fake.enqueueUnsubscribeTrackMutex.RUnlock()
	argsForCall := fake.enqueueUnsubscribeTrackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeLocalParticipant) GetAdaptiveStream() bool {
	fake.getAdaptiveStreamMutex.Lock()
	ret, specificReturn := fake.getAdaptiveStreamReturnsOnCall[len(fake.getAdaptiveStreamArgsForCall)]
	fake.getAdaptiveStreamArgsForCall = append(fake.getAdaptiveStreamArgsForCall, struct {
	}{})
	stub := fake.GetAdaptiveStreamStub
	fakeReturns := fake.getAdaptiveStreamReturns
	fake.recordInvocation("GetAdaptiveStream", []interface{}{})
	fake.getAdaptiveStreamMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) GetAdaptiveStreamCallCount() int {
	fake.getAdaptiveStreamMutex.RLock()
	defer fake.getAdaptiveStreamMutex.RUnlock()
	return len(fake.getAdaptiveStreamArgsForCall)
}

func (fake *FakeLocalParticipant) GetAdaptiveStreamCalls(stub func() bool) {
	fake.getAdaptiveStreamMutex.Lock()
	defer fake.getAdaptiveStreamMutex.Unlock()
	fake.GetAdaptiveStreamStub = stub
}

func (fake *FakeLocalParticipant) GetAdaptiveStreamReturns(result1 bool) {
	fake.getAdaptiveStreamMutex.Lock()
	defer fake.getAdaptiveStreamMutex.Unlock()
	fake.GetAdaptiveStreamStub = nil
	fake.getAdaptiveStreamReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) GetAdaptiveStreamReturnsOnCall(i int, result1 bool) {
	fake.getAdaptiveStreamMutex.Lock()
	defer fake.getAdaptiveStreamMutex.Unlock()
	fake.GetAdaptiveStreamStub = nil
	if fake.getAdaptiveStreamReturnsOnCall == nil {
		fake.getAdaptiveStreamReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.getAdaptiveStreamReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) GetAudioLevel() (float64, bool) {
	fake.getAudioLevelMutex.Lock()
	ret, specificReturn := fake.getAudioLevelReturnsOnCall[len(fake.getAudioLevelArgsForCall)]
	fake.getAudioLevelArgsForCall = append(fake.getAudioLevelArgsForCall, struct {
	}{})
	stub := fake.GetAudioLevelStub
	fakeReturns := fake.getAudioLevelReturns
	fake.recordInvocation("GetAudioLevel", []interface{}{})
	fake.getAudioLevelMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeLocalParticipant) GetAudioLevelCallCount() int {
	fake.getAudioLevelMutex.RLock()
	defer fake.getAudioLevelMutex.RUnlock()
	return len(fake.getAudioLevelArgsForCall)
}

func (fake *FakeLocalParticipant) GetAudioLevelCalls(stub func() (float64, bool)) {
	fake.getAudioLevelMutex.Lock()
	defer fake.getAudioLevelMutex.Unlock()
	fake.GetAudioLevelStub = stub
}

func (fake *FakeLocalParticipant) GetAudioLevelReturns(result1 float64, result2 bool) {
	fake.getAudioLevelMutex.Lock()
	defer fake.getAudioLevelMutex.Unlock()
	fake.GetAudioLevelStub = nil
	fake.getAudioLevelReturns = struct {
		result1 float64
		result2 bool
	}{result1, result2}
}

func (fake *FakeLocalParticipant) GetAudioLevelReturnsOnCall(i int, result1 float64, result2 bool) {
	fake.getAudioLevelMutex.Lock()
	defer fake.getAudioLevelMutex.Unlock()
	fake.GetAudioLevelStub = nil
	if fake.getAudioLevelReturnsOnCall == nil {
		fake.getAudioLevelReturnsOnCall = make(map[int]struct {
			result1 float64
			result2 bool
		})
	}
	fake.getAudioLevelReturnsOnCall[i] = struct {
		result1 float64
		result2 bool
	}{result1, result2}
}

func (fake *FakeLocalParticipant) GetCachedDownTrack(arg1 livekit.TrackID) (*webrtc.RTPTransceiver, sfu.DownTrackState) {
	fake.getCachedDownTrackMutex.Lock()
	ret, specificReturn := fake.getCachedDownTrackReturnsOnCall[len(fake.getCachedDownTrackArgsForCall)]
	fake.getCachedDownTrackArgsForCall = append(fake.getCachedDownTrackArgsForCall, struct {
		arg1 livekit.TrackID
	}{arg1})
	stub := fake.GetCachedDownTrackStub
	fakeReturns := fake.getCachedDownTrackReturns
	fake.recordInvocation("GetCachedDownTrack", []interface{}{arg1})
	fake.getCachedDownTrackMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeLocalParticipant) GetCachedDownTrackCallCount() int {
	fake.getCachedDownTrackMutex.RLock()
	defer fake.getCachedDownTrackMutex.RUnlock()
	return len(fake.getCachedDownTrackArgsForCall)
}

func (fake *FakeLocalParticipant) GetCachedDownTrackCalls(stub func(livekit.TrackID) (*webrtc.RTPTransceiver, sfu.DownTrackState)) {
	fake.getCachedDownTrackMutex.Lock()
	defer fake.getCachedDownTrackMutex.Unlock()
	fake.GetCachedDownTrackStub = stub
}

func (fake *FakeLocalParticipant) GetCachedDownTrackArgsForCall(i int) livekit.TrackID {
	fake.getCachedDownTrackMutex.RLock()
	defer fake.getCachedDownTrackMutex.RUnlock()
	argsForCall := fake.getCachedDownTrackArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) GetCachedDownTrackReturns(result1 *webrtc.RTPTransceiver, result2 sfu.DownTrackState) {
	fake.getCachedDownTrackMutex.Lock()
	defer fake.getCachedDownTrackMutex.Unlock()
	fake.GetCachedDownTrackStub = nil
	fake.getCachedDownTrackReturns = struct {
		result1 *webrtc.RTPTransceiver
		result2 sfu.DownTrackState
	}{result1, result2}
}

func (fake *FakeLocalParticipant) GetCachedDownTrackReturnsOnCall(i int, result1 *webrtc.RTPTransceiver, result2 sfu.DownTrackState) {
	fake.getCachedDownTrackMutex.Lock()
	defer fake.getCachedDownTrackMutex.Unlock()
	fake.GetCachedDownTrackStub = nil
	if fake.getCachedDownTrackReturnsOnCall == nil {
		fake.getCachedDownTrackReturnsOnCall = make(map[int]struct {
			result1 *webrtc.RTPTransceiver
			result2 sfu.DownTrackState
		})
	}
	fake.getCachedDownTrackReturnsOnCall[i] = struct {
		result1 *webrtc.RTPTransceiver
		result2 sfu.DownTrackState
	}{result1, result2}
}

func (fake *FakeLocalParticipant) GetClientConfiguration() *livekit.ClientConfiguration {
	fake.getClientConfigurationMutex.Lock()
	ret, specificReturn := fake.getClientConfigurationReturnsOnCall[len(fake.getClientConfigurationArgsForCall)]
	fake.getClientConfigurationArgsForCall = append(fake.getClientConfigurationArgsForCall, struct {
	}{})
	stub := fake.GetClientConfigurationStub
	fakeReturns := fake.getClientConfigurationReturns
	fake.recordInvocation("GetClientConfiguration", []interface{}{})
	fake.getClientConfigurationMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) GetClientConfigurationCallCount() int {
	fake.getClientConfigurationMutex.RLock()
	defer fake.getClientConfigurationMutex.RUnlock()
	return len(fake.getClientConfigurationArgsForCall)
}

func (fake *FakeLocalParticipant) GetClientConfigurationCalls(stub func() *livekit.ClientConfiguration) {
	fake.getClientConfigurationMutex.Lock()
	defer fake.getClientConfigurationMutex.Unlock()
	fake.GetClientConfigurationStub = stub
}

func (fake *FakeLocalParticipant) GetClientConfigurationReturns(result1 *livekit.ClientConfiguration) {
	fake.getClientConfigurationMutex.Lock()
	defer fake.getClientConfigurationMutex.Unlock()
	fake.GetClientConfigurationStub = nil
	fake.getClientConfigurationReturns = struct {
		result1 *livekit.ClientConfiguration
	}{result1}
}

func (fake *FakeLocalParticipant) GetClientConfigurationReturnsOnCall(i int, result1 *livekit.ClientConfiguration) {
	fake.getClientConfigurationMutex.Lock()
	defer fake.getClientConfigurationMutex.Unlock()
	fake.GetClientConfigurationStub = nil
	if fake.getClientConfigurationReturnsOnCall == nil {
		fake.getClientConfigurationReturnsOnCall = make(map[int]struct {
			result1 *livekit.ClientConfiguration
		})
	}
	fake.getClientConfigurationReturnsOnCall[i] = struct {
		result1 *livekit.ClientConfiguration
	}{result1}
}

func (fake *FakeLocalParticipant) GetConnectionQuality() *livekit.ConnectionQualityInfo {
	fake.getConnectionQualityMutex.Lock()
	ret, specificReturn := fake.getConnectionQualityReturnsOnCall[len(fake.getConnectionQualityArgsForCall)]
	fake.getConnectionQualityArgsForCall = append(fake.getConnectionQualityArgsForCall, struct {
	}{})
	stub := fake.GetConnectionQualityStub
	fakeReturns := fake.getConnectionQualityReturns
	fake.recordInvocation("GetConnectionQuality", []interface{}{})
	fake.getConnectionQualityMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) GetConnectionQualityCallCount() int {
	fake.getConnectionQualityMutex.RLock()
	defer fake.getConnectionQualityMutex.RUnlock()
	return len(fake.getConnectionQualityArgsForCall)
}

func (fake *FakeLocalParticipant) GetConnectionQualityCalls(stub func() *livekit.ConnectionQualityInfo) {
	fake.getConnectionQualityMutex.Lock()
	defer fake.getConnectionQualityMutex.Unlock()
	fake.GetConnectionQualityStub = stub
}

func (fake *FakeLocalParticipant) GetConnectionQualityReturns(result1 *livekit.ConnectionQualityInfo) {
	fake.getConnectionQualityMutex.Lock()
	defer fake.getConnectionQualityMutex.Unlock()
	fake.GetConnectionQualityStub = nil
	fake.getConnectionQualityReturns = struct {
		result1 *livekit.ConnectionQualityInfo
	}{result1}
}

func (fake *FakeLocalParticipant) GetConnectionQualityReturnsOnCall(i int, result1 *livekit.ConnectionQualityInfo) {
	fake.getConnectionQualityMutex.Lock()
	defer fake.getConnectionQualityMutex.Unlock()
	fake.GetConnectionQualityStub = nil
	if fake.getConnectionQualityReturnsOnCall == nil {
		fake.getConnectionQualityReturnsOnCall = make(map[int]struct {
			result1 *livekit.ConnectionQualityInfo
		})
	}
	fake.getConnectionQualityReturnsOnCall[i] = struct {
		result1 *livekit.ConnectionQualityInfo
	}{result1}
}

func (fake *FakeLocalParticipant) GetICEConnectionType() types.ICEConnectionType {
	fake.getICEConnectionTypeMutex.Lock()
	ret, specificReturn := fake.getICEConnectionTypeReturnsOnCall[len(fake.getICEConnectionTypeArgsForCall)]
	fake.getICEConnectionTypeArgsForCall = append(fake.getICEConnectionTypeArgsForCall, struct {
	}{})
	stub := fake.GetICEConnectionTypeStub
	fakeReturns := fake.getICEConnectionTypeReturns
	fake.recordInvocation("GetICEConnectionType", []interface{}{})
	fake.getICEConnectionTypeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) GetICEConnectionTypeCallCount() int {
	fake.getICEConnectionTypeMutex.RLock()
	defer fake.getICEConnectionTypeMutex.RUnlock()
	return len(fake.getICEConnectionTypeArgsForCall)
}

func (fake *FakeLocalParticipant) GetICEConnectionTypeCalls(stub func() types.ICEConnectionType) {
	fake.getICEConnectionTypeMutex.Lock()
	defer fake.getICEConnectionTypeMutex.Unlock()
	fake.GetICEConnectionTypeStub = stub
}

func (fake *FakeLocalParticipant) GetICEConnectionTypeReturns(result1 types.ICEConnectionType) {
	fake.getICEConnectionTypeMutex.Lock()
	defer fake.getICEConnectionTypeMutex.Unlock()
	fake.GetICEConnectionTypeStub = nil
	fake.getICEConnectionTypeReturns = struct {
		result1 types.ICEConnectionType
	}{result1}
}

func (fake *FakeLocalParticipant) GetICEConnectionTypeReturnsOnCall(i int, result1 types.ICEConnectionType) {
	fake.getICEConnectionTypeMutex.Lock()
	defer fake.getICEConnectionTypeMutex.Unlock()
	fake.GetICEConnectionTypeStub = nil
	if fake.getICEConnectionTypeReturnsOnCall == nil {
		fake.getICEConnectionTypeReturnsOnCall = make(map[int]struct {
			result1 types.ICEConnectionType
		})
	}
	fake.getICEConnectionTypeReturnsOnCall[i] = struct {
		result1 types.ICEConnectionType
	}{result1}
}

func (fake *FakeLocalParticipant) GetLogger() logger.Logger {
	fake.getLoggerMutex.Lock()
	ret, specificReturn := fake.getLoggerReturnsOnCall[len(fake.getLoggerArgsForCall)]
	fake.getLoggerArgsForCall = append(fake.getLoggerArgsForCall, struct {
	}{})
	stub := fake.GetLoggerStub
	fakeReturns := fake.getLoggerReturns
	fake.recordInvocation("GetLogger", []interface{}{})
	fake.getLoggerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) GetLoggerCallCount() int {
	fake.getLoggerMutex.RLock()
	defer fake.getLoggerMutex.RUnlock()
	return len(fake.getLoggerArgsForCall)
}

func (fake *FakeLocalParticipant) GetLoggerCalls(stub func() logger.Logger) {
	fake.getLoggerMutex.Lock()
	defer fake.getLoggerMutex.Unlock()
	fake.GetLoggerStub = stub
}

func (fake *FakeLocalParticipant) GetLoggerReturns(result1 logger.Logger) {
	fake.getLoggerMutex.Lock()
	defer fake.getLoggerMutex.Unlock()
	fake.GetLoggerStub = nil
	fake.getLoggerReturns = struct {
		result1 logger.Logger
	}{result1}
}

func (fake *FakeLocalParticipant) GetLoggerReturnsOnCall(i int, result1 logger.Logger) {
	fake.getLoggerMutex.Lock()
	defer fake.getLoggerMutex.Unlock()
	fake.GetLoggerStub = nil
	if fake.getLoggerReturnsOnCall == nil {
		fake.getLoggerReturnsOnCall = make(map[int]struct {
			result1 logger.Logger
		})
	}
	fake.getLoggerReturnsOnCall[i] = struct {
		result1 logger.Logger
	}{result1}
}

func (fake *FakeLocalParticipant) GetPublishedTrack(arg1 livekit.TrackID) types.MediaTrack {
	fake.getPublishedTrackMutex.Lock()
	ret, specificReturn := fake.getPublishedTrackReturnsOnCall[len(fake.getPublishedTrackArgsForCall)]
	fake.getPublishedTrackArgsForCall = append(fake.getPublishedTrackArgsForCall, struct {
		arg1 livekit.TrackID
	}{arg1})
	stub := fake.GetPublishedTrackStub
	fakeReturns := fake.getPublishedTrackReturns
	fake.recordInvocation("GetPublishedTrack", []interface{}{arg1})
	fake.getPublishedTrackMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) GetPublishedTrackCallCount() int {
	fake.getPublishedTrackMutex.RLock()
	defer fake.getPublishedTrackMutex.RUnlock()
	return len(fake.getPublishedTrackArgsForCall)
}

func (fake *FakeLocalParticipant) GetPublishedTrackCalls(stub func(livekit.TrackID) types.MediaTrack) {
	fake.getPublishedTrackMutex.Lock()
	defer fake.getPublishedTrackMutex.Unlock()
	fake.GetPublishedTrackStub = stub
}

func (fake *FakeLocalParticipant) GetPublishedTrackArgsForCall(i int) livekit.TrackID {
	fake.getPublishedTrackMutex.RLock()
	defer fake.getPublishedTrackMutex.RUnlock()
	argsForCall := fake.getPublishedTrackArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) GetPublishedTrackReturns(result1 types.MediaTrack) {
	fake.getPublishedTrackMutex.Lock()
	defer fake.getPublishedTrackMutex.Unlock()
	fake.GetPublishedTrackStub = nil
	fake.getPublishedTrackReturns = struct {
		result1 types.MediaTrack
	}{result1}
}

func (fake *FakeLocalParticipant) GetPublishedTrackReturnsOnCall(i int, result1 types.MediaTrack) {
	fake.getPublishedTrackMutex.Lock()
	defer fake.getPublishedTrackMutex.Unlock()
	fake.GetPublishedTrackStub = nil
	if fake.getPublishedTrackReturnsOnCall == nil {
		fake.getPublishedTrackReturnsOnCall = make(map[int]struct {
			result1 types.MediaTrack
		})
	}
	fake.getPublishedTrackReturnsOnCall[i] = struct {
		result1 types.MediaTrack
	}{result1}
}

func (fake *FakeLocalParticipant) GetPublishedTracks() []types.MediaTrack {
	fake.getPublishedTracksMutex.Lock()
	ret, specificReturn := fake.getPublishedTracksReturnsOnCall[len(fake.getPublishedTracksArgsForCall)]
	fake.getPublishedTracksArgsForCall = append(fake.getPublishedTracksArgsForCall, struct {
	}{})
	stub := fake.GetPublishedTracksStub
	fakeReturns := fake.getPublishedTracksReturns
	fake.recordInvocation("GetPublishedTracks", []interface{}{})
	fake.getPublishedTracksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) GetPublishedTracksCallCount() int {
	fake.getPublishedTracksMutex.RLock()
	defer fake.getPublishedTracksMutex.RUnlock()
	return len(fake.getPublishedTracksArgsForCall)
}

func (fake *FakeLocalParticipant) GetPublishedTracksCalls(stub func() []types.MediaTrack) {
	fake.getPublishedTracksMutex.Lock()
	defer fake.getPublishedTracksMutex.Unlock()
	fake.GetPublishedTracksStub = stub
}

func (fake *FakeLocalParticipant) GetPublishedTracksReturns(result1 []types.MediaTrack) {
	fake.getPublishedTracksMutex.Lock()
	defer fake.getPublishedTracksMutex.Unlock()
	fake.GetPublishedTracksStub = nil
	fake.getPublishedTracksReturns = struct {
		result1 []types.MediaTrack
	}{result1}
}

func (fake *FakeLocalParticipant) GetPublishedTracksReturnsOnCall(i int, result1 []types.MediaTrack) {
	fake.getPublishedTracksMutex.Lock()
	defer fake.getPublishedTracksMutex.Unlock()
	fake.GetPublishedTracksStub = nil
	if fake.getPublishedTracksReturnsOnCall == nil {
		fake.getPublishedTracksReturnsOnCall = make(map[int]struct {
			result1 []types.MediaTrack
		})
	}
	fake.getPublishedTracksReturnsOnCall[i] = struct {
		result1 []types.MediaTrack
	}{result1}
}

func (fake *FakeLocalParticipant) GetSubscribedParticipants() []livekit.ParticipantID {
	fake.getSubscribedParticipantsMutex.Lock()
	ret, specificReturn := fake.getSubscribedParticipantsReturnsOnCall[len(fake.getSubscribedParticipantsArgsForCall)]
	fake.getSubscribedParticipantsArgsForCall = append(fake.getSubscribedParticipantsArgsForCall, struct {
	}{})
	stub := fake.GetSubscribedParticipantsStub
	fakeReturns := fake.getSubscribedParticipantsReturns
	fake.recordInvocation("GetSubscribedParticipants", []interface{}{})
	fake.getSubscribedParticipantsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) GetSubscribedParticipantsCallCount() int {
	fake.getSubscribedParticipantsMutex.RLock()
	defer fake.getSubscribedParticipantsMutex.RUnlock()
	return len(fake.getSubscribedParticipantsArgsForCall)
}

func (fake *FakeLocalParticipant) GetSubscribedParticipantsCalls(stub func() []livekit.ParticipantID) {
	fake.getSubscribedParticipantsMutex.Lock()
	defer fake.getSubscribedParticipantsMutex.Unlock()
	fake.GetSubscribedParticipantsStub = stub
}

func (fake *FakeLocalParticipant) GetSubscribedParticipantsReturns(result1 []livekit.ParticipantID) {
	fake.getSubscribedParticipantsMutex.Lock()
	defer fake.getSubscribedParticipantsMutex.Unlock()
	fake.GetSubscribedParticipantsStub = nil
	fake.getSubscribedParticipantsReturns = struct {
		result1 []livekit.ParticipantID
	}{result1}
}

func (fake *FakeLocalParticipant) GetSubscribedParticipantsReturnsOnCall(i int, result1 []livekit.ParticipantID) {
	fake.getSubscribedParticipantsMutex.Lock()
	defer fake.getSubscribedParticipantsMutex.Unlock()
	fake.GetSubscribedParticipantsStub = nil
	if fake.getSubscribedParticipantsReturnsOnCall == nil {
		fake.getSubscribedParticipantsReturnsOnCall = make(map[int]struct {
			result1 []livekit.ParticipantID
		})
	}
	fake.getSubscribedParticipantsReturnsOnCall[i] = struct {
		result1 []livekit.ParticipantID
	}{result1}
}

func (fake *FakeLocalParticipant) GetSubscribedTracks() []types.SubscribedTrack {
	fake.getSubscribedTracksMutex.Lock()
	ret, specificReturn := fake.getSubscribedTracksReturnsOnCall[len(fake.getSubscribedTracksArgsForCall)]
	fake.getSubscribedTracksArgsForCall = append(fake.getSubscribedTracksArgsForCall, struct {
	}{})
	stub := fake.GetSubscribedTracksStub
	fakeReturns := fake.getSubscribedTracksReturns
	fake.recordInvocation("GetSubscribedTracks", []interface{}{})
	fake.getSubscribedTracksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) GetSubscribedTracksCallCount() int {
	fake.getSubscribedTracksMutex.RLock()
	defer fake.getSubscribedTracksMutex.RUnlock()
	return len(fake.getSubscribedTracksArgsForCall)
}

func (fake *FakeLocalParticipant) GetSubscribedTracksCalls(stub func() []types.SubscribedTrack) {
	fake.getSubscribedTracksMutex.Lock()
	defer fake.getSubscribedTracksMutex.Unlock()
	fake.GetSubscribedTracksStub = stub
}

func (fake *FakeLocalParticipant) GetSubscribedTracksReturns(result1 []types.SubscribedTrack) {
	fake.getSubscribedTracksMutex.Lock()
	defer fake.getSubscribedTracksMutex.Unlock()
	fake.GetSubscribedTracksStub = nil
	fake.getSubscribedTracksReturns = struct {
		result1 []types.SubscribedTrack
	}{result1}
}

func (fake *FakeLocalParticipant) GetSubscribedTracksReturnsOnCall(i int, result1 []types.SubscribedTrack) {
	fake.getSubscribedTracksMutex.Lock()
	defer fake.getSubscribedTracksMutex.Unlock()
	fake.GetSubscribedTracksStub = nil
	if fake.getSubscribedTracksReturnsOnCall == nil {
		fake.getSubscribedTracksReturnsOnCall = make(map[int]struct {
			result1 []types.SubscribedTrack
		})
	}
	fake.getSubscribedTracksReturnsOnCall[i] = struct {
		result1 []types.SubscribedTrack
	}{result1}
}

func (fake *FakeLocalParticipant) HandleAnswer(arg1 webrtc.SessionDescription) {
	fake.handleAnswerMutex.Lock()
	fake.handleAnswerArgsForCall = append(fake.handleAnswerArgsForCall, struct {
		arg1 webrtc.SessionDescription
	}{arg1})
	stub := fake.HandleAnswerStub
	fake.recordInvocation("HandleAnswer", []interface{}{arg1})
	fake.handleAnswerMutex.Unlock()
	if stub != nil {
		fake.HandleAnswerStub(arg1)
	}
}

func (fake *FakeLocalParticipant) HandleAnswerCallCount() int {
	fake.handleAnswerMutex.RLock()
	defer fake.handleAnswerMutex.RUnlock()
	return len(fake.handleAnswerArgsForCall)
}

func (fake *FakeLocalParticipant) HandleAnswerCalls(stub func(webrtc.SessionDescription)) {
	fake.handleAnswerMutex.Lock()
	defer fake.handleAnswerMutex.Unlock()
	fake.HandleAnswerStub = stub
}

func (fake *FakeLocalParticipant) HandleAnswerArgsForCall(i int) webrtc.SessionDescription {
	fake.handleAnswerMutex.RLock()
	defer fake.handleAnswerMutex.RUnlock()
	argsForCall := fake.handleAnswerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) HandleOffer(arg1 webrtc.SessionDescription) {
	fake.handleOfferMutex.Lock()
	fake.handleOfferArgsForCall = append(fake.handleOfferArgsForCall, struct {
		arg1 webrtc.SessionDescription
	}{arg1})
	stub := fake.HandleOfferStub
	fake.recordInvocation("HandleOffer", []interface{}{arg1})
	fake.handleOfferMutex.Unlock()
	if stub != nil {
		fake.HandleOfferStub(arg1)
	}
}

func (fake *FakeLocalParticipant) HandleOfferCallCount() int {
	fake.handleOfferMutex.RLock()
	defer fake.handleOfferMutex.RUnlock()
	return len(fake.handleOfferArgsForCall)
}

func (fake *FakeLocalParticipant) HandleOfferCalls(stub func(webrtc.SessionDescription)) {
	fake.handleOfferMutex.Lock()
	defer fake.handleOfferMutex.Unlock()
	fake.HandleOfferStub = stub
}

func (fake *FakeLocalParticipant) HandleOfferArgsForCall(i int) webrtc.SessionDescription {
	fake.handleOfferMutex.RLock()
	defer fake.handleOfferMutex.RUnlock()
	argsForCall := fake.handleOfferArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) Hidden() bool {
	fake.hiddenMutex.Lock()
	ret, specificReturn := fake.hiddenReturnsOnCall[len(fake.hiddenArgsForCall)]
	fake.hiddenArgsForCall = append(fake.hiddenArgsForCall, struct {
	}{})
	stub := fake.HiddenStub
	fakeReturns := fake.hiddenReturns
	fake.recordInvocation("Hidden", []interface{}{})
	fake.hiddenMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) HiddenCallCount() int {
	fake.hiddenMutex.RLock()
	defer fake.hiddenMutex.RUnlock()
	return len(fake.hiddenArgsForCall)
}

func (fake *FakeLocalParticipant) HiddenCalls(stub func() bool) {
	fake.hiddenMutex.Lock()
	defer fake.hiddenMutex.Unlock()
	fake.HiddenStub = stub
}

func (fake *FakeLocalParticipant) HiddenReturns(result1 bool) {
	fake.hiddenMutex.Lock()
	defer fake.hiddenMutex.Unlock()
	fake.HiddenStub = nil
	fake.hiddenReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) HiddenReturnsOnCall(i int, result1 bool) {
	fake.hiddenMutex.Lock()
	defer fake.hiddenMutex.Unlock()
	fake.HiddenStub = nil
	if fake.hiddenReturnsOnCall == nil {
		fake.hiddenReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.hiddenReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) ICERestart(arg1 *types.IceConfig) {
	fake.iCERestartMutex.Lock()
	fake.iCERestartArgsForCall = append(fake.iCERestartArgsForCall, struct {
		arg1 *types.IceConfig
	}{arg1})
	stub := fake.ICERestartStub
	fake.recordInvocation("ICERestart", []interface{}{arg1})
	fake.iCERestartMutex.Unlock()
	if stub != nil {
		fake.ICERestartStub(arg1)
	}
}

func (fake *FakeLocalParticipant) ICERestartCallCount() int {
	fake.iCERestartMutex.RLock()
	defer fake.iCERestartMutex.RUnlock()
	return len(fake.iCERestartArgsForCall)
}

func (fake *FakeLocalParticipant) ICERestartCalls(stub func(*types.IceConfig)) {
	fake.iCERestartMutex.Lock()
	defer fake.iCERestartMutex.Unlock()
	fake.ICERestartStub = stub
}

func (fake *FakeLocalParticipant) ICERestartArgsForCall(i int) *types.IceConfig {
	fake.iCERestartMutex.RLock()
	defer fake.iCERestartMutex.RUnlock()
	argsForCall := fake.iCERestartArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) ID() livekit.ParticipantID {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	stub := fake.IDStub
	fakeReturns := fake.iDReturns
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeLocalParticipant) IDCalls(stub func() livekit.ParticipantID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeLocalParticipant) IDReturns(result1 livekit.ParticipantID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 livekit.ParticipantID
	}{result1}
}

func (fake *FakeLocalParticipant) IDReturnsOnCall(i int, result1 livekit.ParticipantID) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 livekit.ParticipantID
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 livekit.ParticipantID
	}{result1}
}

func (fake *FakeLocalParticipant) Identity() livekit.ParticipantIdentity {
	fake.identityMutex.Lock()
	ret, specificReturn := fake.identityReturnsOnCall[len(fake.identityArgsForCall)]
	fake.identityArgsForCall = append(fake.identityArgsForCall, struct {
	}{})
	stub := fake.IdentityStub
	fakeReturns := fake.identityReturns
	fake.recordInvocation("Identity", []interface{}{})
	fake.identityMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) IdentityCallCount() int {
	fake.identityMutex.RLock()
	defer fake.identityMutex.RUnlock()
	return len(fake.identityArgsForCall)
}

func (fake *FakeLocalParticipant) IdentityCalls(stub func() livekit.ParticipantIdentity) {
	fake.identityMutex.Lock()
	defer fake.identityMutex.Unlock()
	fake.IdentityStub = stub
}

func (fake *FakeLocalParticipant) IdentityReturns(result1 livekit.ParticipantIdentity) {
	fake.identityMutex.Lock()
	defer fake.identityMutex.Unlock()
	fake.IdentityStub = nil
	fake.identityReturns = struct {
		result1 livekit.ParticipantIdentity
	}{result1}
}

func (fake *FakeLocalParticipant) IdentityReturnsOnCall(i int, result1 livekit.ParticipantIdentity) {
	fake.identityMutex.Lock()
	defer fake.identityMutex.Unlock()
	fake.IdentityStub = nil
	if fake.identityReturnsOnCall == nil {
		fake.identityReturnsOnCall = make(map[int]struct {
			result1 livekit.ParticipantIdentity
		})
	}
	fake.identityReturnsOnCall[i] = struct {
		result1 livekit.ParticipantIdentity
	}{result1}
}

func (fake *FakeLocalParticipant) IsPublisher() bool {
	fake.isPublisherMutex.Lock()
	ret, specificReturn := fake.isPublisherReturnsOnCall[len(fake.isPublisherArgsForCall)]
	fake.isPublisherArgsForCall = append(fake.isPublisherArgsForCall, struct {
	}{})
	stub := fake.IsPublisherStub
	fakeReturns := fake.isPublisherReturns
	fake.recordInvocation("IsPublisher", []interface{}{})
	fake.isPublisherMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) IsPublisherCallCount() int {
	fake.isPublisherMutex.RLock()
	defer fake.isPublisherMutex.RUnlock()
	return len(fake.isPublisherArgsForCall)
}

func (fake *FakeLocalParticipant) IsPublisherCalls(stub func() bool) {
	fake.isPublisherMutex.Lock()
	defer fake.isPublisherMutex.Unlock()
	fake.IsPublisherStub = stub
}

func (fake *FakeLocalParticipant) IsPublisherReturns(result1 bool) {
	fake.isPublisherMutex.Lock()
	defer fake.isPublisherMutex.Unlock()
	fake.IsPublisherStub = nil
	fake.isPublisherReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) IsPublisherReturnsOnCall(i int, result1 bool) {
	fake.isPublisherMutex.Lock()
	defer fake.isPublisherMutex.Unlock()
	fake.IsPublisherStub = nil
	if fake.isPublisherReturnsOnCall == nil {
		fake.isPublisherReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isPublisherReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) IsReady() bool {
	fake.isReadyMutex.Lock()
	ret, specificReturn := fake.isReadyReturnsOnCall[len(fake.isReadyArgsForCall)]
	fake.isReadyArgsForCall = append(fake.isReadyArgsForCall, struct {
	}{})
	stub := fake.IsReadyStub
	fakeReturns := fake.isReadyReturns
	fake.recordInvocation("IsReady", []interface{}{})
	fake.isReadyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) IsReadyCallCount() int {
	fake.isReadyMutex.RLock()
	defer fake.isReadyMutex.RUnlock()
	return len(fake.isReadyArgsForCall)
}

func (fake *FakeLocalParticipant) IsReadyCalls(stub func() bool) {
	fake.isReadyMutex.Lock()
	defer fake.isReadyMutex.Unlock()
	fake.IsReadyStub = stub
}

func (fake *FakeLocalParticipant) IsReadyReturns(result1 bool) {
	fake.isReadyMutex.Lock()
	defer fake.isReadyMutex.Unlock()
	fake.IsReadyStub = nil
	fake.isReadyReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) IsReadyReturnsOnCall(i int, result1 bool) {
	fake.isReadyMutex.Lock()
	defer fake.isReadyMutex.Unlock()
	fake.IsReadyStub = nil
	if fake.isReadyReturnsOnCall == nil {
		fake.isReadyReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isReadyReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) IsRecorder() bool {
	fake.isRecorderMutex.Lock()
	ret, specificReturn := fake.isRecorderReturnsOnCall[len(fake.isRecorderArgsForCall)]
	fake.isRecorderArgsForCall = append(fake.isRecorderArgsForCall, struct {
	}{})
	stub := fake.IsRecorderStub
	fakeReturns := fake.isRecorderReturns
	fake.recordInvocation("IsRecorder", []interface{}{})
	fake.isRecorderMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) IsRecorderCallCount() int {
	fake.isRecorderMutex.RLock()
	defer fake.isRecorderMutex.RUnlock()
	return len(fake.isRecorderArgsForCall)
}

func (fake *FakeLocalParticipant) IsRecorderCalls(stub func() bool) {
	fake.isRecorderMutex.Lock()
	defer fake.isRecorderMutex.Unlock()
	fake.IsRecorderStub = stub
}

func (fake *FakeLocalParticipant) IsRecorderReturns(result1 bool) {
	fake.isRecorderMutex.Lock()
	defer fake.isRecorderMutex.Unlock()
	fake.IsRecorderStub = nil
	fake.isRecorderReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) IsRecorderReturnsOnCall(i int, result1 bool) {
	fake.isRecorderMutex.Lock()
	defer fake.isRecorderMutex.Unlock()
	fake.IsRecorderStub = nil
	if fake.isRecorderReturnsOnCall == nil {
		fake.isRecorderReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isRecorderReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) IsSubscribedTo(arg1 livekit.ParticipantID) bool {
	fake.isSubscribedToMutex.Lock()
	ret, specificReturn := fake.isSubscribedToReturnsOnCall[len(fake.isSubscribedToArgsForCall)]
	fake.isSubscribedToArgsForCall = append(fake.isSubscribedToArgsForCall, struct {
		arg1 livekit.ParticipantID
	}{arg1})
	stub := fake.IsSubscribedToStub
	fakeReturns := fake.isSubscribedToReturns
	fake.recordInvocation("IsSubscribedTo", []interface{}{arg1})
	fake.isSubscribedToMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) IsSubscribedToCallCount() int {
	fake.isSubscribedToMutex.RLock()
	defer fake.isSubscribedToMutex.RUnlock()
	return len(fake.isSubscribedToArgsForCall)
}

func (fake *FakeLocalParticipant) IsSubscribedToCalls(stub func(livekit.ParticipantID) bool) {
	fake.isSubscribedToMutex.Lock()
	defer fake.isSubscribedToMutex.Unlock()
	fake.IsSubscribedToStub = stub
}

func (fake *FakeLocalParticipant) IsSubscribedToArgsForCall(i int) livekit.ParticipantID {
	fake.isSubscribedToMutex.RLock()
	defer fake.isSubscribedToMutex.RUnlock()
	argsForCall := fake.isSubscribedToArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) IsSubscribedToReturns(result1 bool) {
	fake.isSubscribedToMutex.Lock()
	defer fake.isSubscribedToMutex.Unlock()
	fake.IsSubscribedToStub = nil
	fake.isSubscribedToReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) IsSubscribedToReturnsOnCall(i int, result1 bool) {
	fake.isSubscribedToMutex.Lock()
	defer fake.isSubscribedToMutex.Unlock()
	fake.IsSubscribedToStub = nil
	if fake.isSubscribedToReturnsOnCall == nil {
		fake.isSubscribedToReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isSubscribedToReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) MaybeStartMigration(arg1 bool, arg2 func()) bool {
	fake.maybeStartMigrationMutex.Lock()
	ret, specificReturn := fake.maybeStartMigrationReturnsOnCall[len(fake.maybeStartMigrationArgsForCall)]
	fake.maybeStartMigrationArgsForCall = append(fake.maybeStartMigrationArgsForCall, struct {
		arg1 bool
		arg2 func()
	}{arg1, arg2})
	stub := fake.MaybeStartMigrationStub
	fakeReturns := fake.maybeStartMigrationReturns
	fake.recordInvocation("MaybeStartMigration", []interface{}{arg1, arg2})
	fake.maybeStartMigrationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) MaybeStartMigrationCallCount() int {
	fake.maybeStartMigrationMutex.RLock()
	defer fake.maybeStartMigrationMutex.RUnlock()
	return len(fake.maybeStartMigrationArgsForCall)
}

func (fake *FakeLocalParticipant) MaybeStartMigrationCalls(stub func(bool, func()) bool) {
	fake.maybeStartMigrationMutex.Lock()
	defer fake.maybeStartMigrationMutex.Unlock()
	fake.MaybeStartMigrationStub = stub
}

func (fake *FakeLocalParticipant) MaybeStartMigrationArgsForCall(i int) (bool, func()) {
	fake.maybeStartMigrationMutex.RLock()
	defer fake.maybeStartMigrationMutex.RUnlock()
	argsForCall := fake.maybeStartMigrationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipant) MaybeStartMigrationReturns(result1 bool) {
	fake.maybeStartMigrationMutex.Lock()
	defer fake.maybeStartMigrationMutex.Unlock()
	fake.MaybeStartMigrationStub = nil
	fake.maybeStartMigrationReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) MaybeStartMigrationReturnsOnCall(i int, result1 bool) {
	fake.maybeStartMigrationMutex.Lock()
	defer fake.maybeStartMigrationMutex.Unlock()
	fake.MaybeStartMigrationStub = nil
	if fake.maybeStartMigrationReturnsOnCall == nil {
		fake.maybeStartMigrationReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.maybeStartMigrationReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) MigrateState() types.MigrateState {
	fake.migrateStateMutex.Lock()
	ret, specificReturn := fake.migrateStateReturnsOnCall[len(fake.migrateStateArgsForCall)]
	fake.migrateStateArgsForCall = append(fake.migrateStateArgsForCall, struct {
	}{})
	stub := fake.MigrateStateStub
	fakeReturns := fake.migrateStateReturns
	fake.recordInvocation("MigrateState", []interface{}{})
	fake.migrateStateMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) MigrateStateCallCount() int {
	fake.migrateStateMutex.RLock()
	defer fake.migrateStateMutex.RUnlock()
	return len(fake.migrateStateArgsForCall)
}

func (fake *FakeLocalParticipant) MigrateStateCalls(stub func() types.MigrateState) {
	fake.migrateStateMutex.Lock()
	defer fake.migrateStateMutex.Unlock()
	fake.MigrateStateStub = stub
}

func (fake *FakeLocalParticipant) MigrateStateReturns(result1 types.MigrateState) {
	fake.migrateStateMutex.Lock()
	defer fake.migrateStateMutex.Unlock()
	fake.MigrateStateStub = nil
	fake.migrateStateReturns = struct {
		result1 types.MigrateState
	}{result1}
}

func (fake *FakeLocalParticipant) MigrateStateReturnsOnCall(i int, result1 types.MigrateState) {
	fake.migrateStateMutex.Lock()
	defer fake.migrateStateMutex.Unlock()
	fake.MigrateStateStub = nil
	if fake.migrateStateReturnsOnCall == nil {
		fake.migrateStateReturnsOnCall = make(map[int]struct {
			result1 types.MigrateState
		})
	}
	fake.migrateStateReturnsOnCall[i] = struct {
		result1 types.MigrateState
	}{result1}
}

func (fake *FakeLocalParticipant) Negotiate(arg1 bool) {
	fake.negotiateMutex.Lock()
	fake.negotiateArgsForCall = append(fake.negotiateArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.NegotiateStub
	fake.recordInvocation("Negotiate", []interface{}{arg1})
	fake.negotiateMutex.Unlock()
	if stub != nil {
		fake.NegotiateStub(arg1)
	}
}

func (fake *FakeLocalParticipant) NegotiateCallCount() int {
	fake.negotiateMutex.RLock()
	defer fake.negotiateMutex.RUnlock()
	return len(fake.negotiateArgsForCall)
}

func (fake *FakeLocalParticipant) NegotiateCalls(stub func(bool)) {
	fake.negotiateMutex.Lock()
	defer fake.negotiateMutex.Unlock()
	fake.NegotiateStub = stub
}

func (fake *FakeLocalParticipant) NegotiateArgsForCall(i int) bool {
	fake.negotiateMutex.RLock()
	defer fake.negotiateMutex.RUnlock()
	argsForCall := fake.negotiateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) OnClaimsChanged(arg1 func(types.LocalParticipant)) {
	fake.onClaimsChangedMutex.Lock()
	fake.onClaimsChangedArgsForCall = append(fake.onClaimsChangedArgsForCall, struct {
		arg1 func(types.LocalParticipant)
	}{arg1})
	stub := fake.OnClaimsChangedStub
	fake.recordInvocation("OnClaimsChanged", []interface{}{arg1})
	fake.onClaimsChangedMutex.Unlock()
	if stub != nil {
		fake.OnClaimsChangedStub(arg1)
	}
}

func (fake *FakeLocalParticipant) OnClaimsChangedCallCount() int {
	fake.onClaimsChangedMutex.RLock()
	defer fake.onClaimsChangedMutex.RUnlock()
	return len(fake.onClaimsChangedArgsForCall)
}

func (fake *FakeLocalParticipant) OnClaimsChangedCalls(stub func(func(types.LocalParticipant))) {
	fake.onClaimsChangedMutex.Lock()
	defer fake.onClaimsChangedMutex.Unlock()
	fake.OnClaimsChangedStub = stub
}

func (fake *FakeLocalParticipant) OnClaimsChangedArgsForCall(i int) func(types.LocalParticipant) {
	fake.onClaimsChangedMutex.RLock()
	defer fake.onClaimsChangedMutex.RUnlock()
	argsForCall := fake.onClaimsChangedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) OnClose(arg1 func(types.LocalParticipant, map[livekit.TrackID]livekit.ParticipantID)) {
	fake.onCloseMutex.Lock()
	fake.onCloseArgsForCall = append(fake.onCloseArgsForCall, struct {
		arg1 func(types.LocalParticipant, map[livekit.TrackID]livekit.ParticipantID)
	}{arg1})
	stub := fake.OnCloseStub
	fake.recordInvocation("OnClose", []interface{}{arg1})
	fake.onCloseMutex.Unlock()
	if stub != nil {
		fake.OnCloseStub(arg1)
	}
}

func (fake *FakeLocalParticipant) OnCloseCallCount() int {
	fake.onCloseMutex.RLock()
	defer fake.onCloseMutex.RUnlock()
	return len(fake.onCloseArgsForCall)
}

func (fake *FakeLocalParticipant) OnCloseCalls(stub func(func(types.LocalParticipant, map[livekit.TrackID]livekit.ParticipantID))) {
	fake.onCloseMutex.Lock()
	defer fake.onCloseMutex.Unlock()
	fake.OnCloseStub = stub
}

func (fake *FakeLocalParticipant) OnCloseArgsForCall(i int) func(types.LocalParticipant, map[livekit.TrackID]livekit.ParticipantID) {
	fake.onCloseMutex.RLock()
	defer fake.onCloseMutex.RUnlock()
	argsForCall := fake.onCloseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) OnDataPacket(arg1 func(types.LocalParticipant, *livekit.DataPacket)) {
	fake.onDataPacketMutex.Lock()
	fake.onDataPacketArgsForCall = append(fake.onDataPacketArgsForCall, struct {
		arg1 func(types.LocalParticipant, *livekit.DataPacket)
	}{arg1})
	stub := fake.OnDataPacketStub
	fake.recordInvocation("OnDataPacket", []interface{}{arg1})
	fake.onDataPacketMutex.Unlock()
	if stub != nil {
		fake.OnDataPacketStub(arg1)
	}
}

func (fake *FakeLocalParticipant) OnDataPacketCallCount() int {
	fake.onDataPacketMutex.RLock()
	defer fake.onDataPacketMutex.RUnlock()
	return len(fake.onDataPacketArgsForCall)
}

func (fake *FakeLocalParticipant) OnDataPacketCalls(stub func(func(types.LocalParticipant, *livekit.DataPacket))) {
	fake.onDataPacketMutex.Lock()
	defer fake.onDataPacketMutex.Unlock()
	fake.OnDataPacketStub = stub
}

func (fake *FakeLocalParticipant) OnDataPacketArgsForCall(i int) func(types.LocalParticipant, *livekit.DataPacket) {
	fake.onDataPacketMutex.RLock()
	defer fake.onDataPacketMutex.RUnlock()
	argsForCall := fake.onDataPacketArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) OnICEConfigChanged(arg1 func(participant types.LocalParticipant, iceConfig types.IceConfig)) {
	fake.onICEConfigChangedMutex.Lock()
	fake.onICEConfigChangedArgsForCall = append(fake.onICEConfigChangedArgsForCall, struct {
		arg1 func(participant types.LocalParticipant, iceConfig types.IceConfig)
	}{arg1})
	stub := fake.OnICEConfigChangedStub
	fake.recordInvocation("OnICEConfigChanged", []interface{}{arg1})
	fake.onICEConfigChangedMutex.Unlock()
	if stub != nil {
		fake.OnICEConfigChangedStub(arg1)
	}
}

func (fake *FakeLocalParticipant) OnICEConfigChangedCallCount() int {
	fake.onICEConfigChangedMutex.RLock()
	defer fake.onICEConfigChangedMutex.RUnlock()
	return len(fake.onICEConfigChangedArgsForCall)
}

func (fake *FakeLocalParticipant) OnICEConfigChangedCalls(stub func(func(participant types.LocalParticipant, iceConfig types.IceConfig))) {
	fake.onICEConfigChangedMutex.Lock()
	defer fake.onICEConfigChangedMutex.Unlock()
	fake.OnICEConfigChangedStub = stub
}

func (fake *FakeLocalParticipant) OnICEConfigChangedArgsForCall(i int) func(participant types.LocalParticipant, iceConfig types.IceConfig) {
	fake.onICEConfigChangedMutex.RLock()
	defer fake.onICEConfigChangedMutex.RUnlock()
	argsForCall := fake.onICEConfigChangedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) OnParticipantUpdate(arg1 func(types.LocalParticipant)) {
	fake.onParticipantUpdateMutex.Lock()
	fake.onParticipantUpdateArgsForCall = append(fake.onParticipantUpdateArgsForCall, struct {
		arg1 func(types.LocalParticipant)
	}{arg1})
	stub := fake.OnParticipantUpdateStub
	fake.recordInvocation("OnParticipantUpdate", []interface{}{arg1})
	fake.onParticipantUpdateMutex.Unlock()
	if stub != nil {
		fake.OnParticipantUpdateStub(arg1)
	}
}

func (fake *FakeLocalParticipant) OnParticipantUpdateCallCount() int {
	fake.onParticipantUpdateMutex.RLock()
	defer fake.onParticipantUpdateMutex.RUnlock()
	return len(fake.onParticipantUpdateArgsForCall)
}

func (fake *FakeLocalParticipant) OnParticipantUpdateCalls(stub func(func(types.LocalParticipant))) {
	fake.onParticipantUpdateMutex.Lock()
	defer fake.onParticipantUpdateMutex.Unlock()
	fake.OnParticipantUpdateStub = stub
}

func (fake *FakeLocalParticipant) OnParticipantUpdateArgsForCall(i int) func(types.LocalParticipant) {
	fake.onParticipantUpdateMutex.RLock()
	defer fake.onParticipantUpdateMutex.RUnlock()
	argsForCall := fake.onParticipantUpdateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) OnReceiverReport(arg1 *sfu.DownTrack, arg2 *rtcp.ReceiverReport) {
	fake.onReceiverReportMutex.Lock()
	fake.onReceiverReportArgsForCall = append(fake.onReceiverReportArgsForCall, struct {
		arg1 *sfu.DownTrack
		arg2 *rtcp.ReceiverReport
	}{arg1, arg2})
	stub := fake.OnReceiverReportStub
	fake.recordInvocation("OnReceiverReport", []interface{}{arg1, arg2})
	fake.onReceiverReportMutex.Unlock()
	if stub != nil {
		fake.OnReceiverReportStub(arg1, arg2)
	}
}

func (fake *FakeLocalParticipant) OnReceiverReportCallCount() int {
	fake.onReceiverReportMutex.RLock()
	defer fake.onReceiverReportMutex.RUnlock()
	return len(fake.onReceiverReportArgsForCall)
}

func (fake *FakeLocalParticipant) OnReceiverReportCalls(stub func(*sfu.DownTrack, *rtcp.ReceiverReport)) {
	fake.onReceiverReportMutex.Lock()
	defer fake.onReceiverReportMutex.Unlock()
	fake.OnReceiverReportStub = stub
}

func (fake *FakeLocalParticipant) OnReceiverReportArgsForCall(i int) (*sfu.DownTrack, *rtcp.ReceiverReport) {
	fake.onReceiverReportMutex.RLock()
	defer fake.onReceiverReportMutex.RUnlock()
	argsForCall := fake.onReceiverReportArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipant) OnStateChange(arg1 func(p types.LocalParticipant, oldState livekit.ParticipantInfo_State)) {
	fake.onStateChangeMutex.Lock()
	fake.onStateChangeArgsForCall = append(fake.onStateChangeArgsForCall, struct {
		arg1 func(p types.LocalParticipant, oldState livekit.ParticipantInfo_State)
	}{arg1})
	stub := fake.OnStateChangeStub
	fake.recordInvocation("OnStateChange", []interface{}{arg1})
	fake.onStateChangeMutex.Unlock()
	if stub != nil {
		fake.OnStateChangeStub(arg1)
	}
}

func (fake *FakeLocalParticipant) OnStateChangeCallCount() int {
	fake.onStateChangeMutex.RLock()
	defer fake.onStateChangeMutex.RUnlock()
	return len(fake.onStateChangeArgsForCall)
}

func (fake *FakeLocalParticipant) OnStateChangeCalls(stub func(func(p types.LocalParticipant, oldState livekit.ParticipantInfo_State))) {
	fake.onStateChangeMutex.Lock()
	defer fake.onStateChangeMutex.Unlock()
	fake.OnStateChangeStub = stub
}

func (fake *FakeLocalParticipant) OnStateChangeArgsForCall(i int) func(p types.LocalParticipant, oldState livekit.ParticipantInfo_State) {
	fake.onStateChangeMutex.RLock()
	defer fake.onStateChangeMutex.RUnlock()
	argsForCall := fake.onStateChangeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) OnSubscribedTo(arg1 func(types.LocalParticipant, livekit.ParticipantID)) {
	fake.onSubscribedToMutex.Lock()
	fake.onSubscribedToArgsForCall = append(fake.onSubscribedToArgsForCall, struct {
		arg1 func(types.LocalParticipant, livekit.ParticipantID)
	}{arg1})
	stub := fake.OnSubscribedToStub
	fake.recordInvocation("OnSubscribedTo", []interface{}{arg1})
	fake.onSubscribedToMutex.Unlock()
	if stub != nil {
		fake.OnSubscribedToStub(arg1)
	}
}

func (fake *FakeLocalParticipant) OnSubscribedToCallCount() int {
	fake.onSubscribedToMutex.RLock()
	defer fake.onSubscribedToMutex.RUnlock()
	return len(fake.onSubscribedToArgsForCall)
}

func (fake *FakeLocalParticipant) OnSubscribedToCalls(stub func(func(types.LocalParticipant, livekit.ParticipantID))) {
	fake.onSubscribedToMutex.Lock()
	defer fake.onSubscribedToMutex.Unlock()
	fake.OnSubscribedToStub = stub
}

func (fake *FakeLocalParticipant) OnSubscribedToArgsForCall(i int) func(types.LocalParticipant, livekit.ParticipantID) {
	fake.onSubscribedToMutex.RLock()
	defer fake.onSubscribedToMutex.RUnlock()
	argsForCall := fake.onSubscribedToArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) OnTrackPublished(arg1 func(types.LocalParticipant, types.MediaTrack)) {
	fake.onTrackPublishedMutex.Lock()
	fake.onTrackPublishedArgsForCall = append(fake.onTrackPublishedArgsForCall, struct {
		arg1 func(types.LocalParticipant, types.MediaTrack)
	}{arg1})
	stub := fake.OnTrackPublishedStub
	fake.recordInvocation("OnTrackPublished", []interface{}{arg1})
	fake.onTrackPublishedMutex.Unlock()
	if stub != nil {
		fake.OnTrackPublishedStub(arg1)
	}
}

func (fake *FakeLocalParticipant) OnTrackPublishedCallCount() int {
	fake.onTrackPublishedMutex.RLock()
	defer fake.onTrackPublishedMutex.RUnlock()
	return len(fake.onTrackPublishedArgsForCall)
}

func (fake *FakeLocalParticipant) OnTrackPublishedCalls(stub func(func(types.LocalParticipant, types.MediaTrack))) {
	fake.onTrackPublishedMutex.Lock()
	defer fake.onTrackPublishedMutex.Unlock()
	fake.OnTrackPublishedStub = stub
}

func (fake *FakeLocalParticipant) OnTrackPublishedArgsForCall(i int) func(types.LocalParticipant, types.MediaTrack) {
	fake.onTrackPublishedMutex.RLock()
	defer fake.onTrackPublishedMutex.RUnlock()
	argsForCall := fake.onTrackPublishedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) OnTrackUpdated(arg1 func(types.LocalParticipant, types.MediaTrack)) {
	fake.onTrackUpdatedMutex.Lock()
	fake.onTrackUpdatedArgsForCall = append(fake.onTrackUpdatedArgsForCall, struct {
		arg1 func(types.LocalParticipant, types.MediaTrack)
	}{arg1})
	stub := fake.OnTrackUpdatedStub
	fake.recordInvocation("OnTrackUpdated", []interface{}{arg1})
	fake.onTrackUpdatedMutex.Unlock()
	if stub != nil {
		fake.OnTrackUpdatedStub(arg1)
	}
}

func (fake *FakeLocalParticipant) OnTrackUpdatedCallCount() int {
	fake.onTrackUpdatedMutex.RLock()
	defer fake.onTrackUpdatedMutex.RUnlock()
	return len(fake.onTrackUpdatedArgsForCall)
}

func (fake *FakeLocalParticipant) OnTrackUpdatedCalls(stub func(func(types.LocalParticipant, types.MediaTrack))) {
	fake.onTrackUpdatedMutex.Lock()
	defer fake.onTrackUpdatedMutex.Unlock()
	fake.OnTrackUpdatedStub = stub
}

func (fake *FakeLocalParticipant) OnTrackUpdatedArgsForCall(i int) func(types.LocalParticipant, types.MediaTrack) {
	fake.onTrackUpdatedMutex.RLock()
	defer fake.onTrackUpdatedMutex.RUnlock()
	argsForCall := fake.onTrackUpdatedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) ProcessSubscriptionRequestsQueue(arg1 livekit.TrackID) {
	fake.processSubscriptionRequestsQueueMutex.Lock()
	fake.processSubscriptionRequestsQueueArgsForCall = append(fake.processSubscriptionRequestsQueueArgsForCall, struct {
		arg1 livekit.TrackID
	}{arg1})
	stub := fake.ProcessSubscriptionRequestsQueueStub
	fake.recordInvocation("ProcessSubscriptionRequestsQueue", []interface{}{arg1})
	fake.processSubscriptionRequestsQueueMutex.Unlock()
	if stub != nil {
		fake.ProcessSubscriptionRequestsQueueStub(arg1)
	}
}

func (fake *FakeLocalParticipant) ProcessSubscriptionRequestsQueueCallCount() int {
	fake.processSubscriptionRequestsQueueMutex.RLock()
	defer fake.processSubscriptionRequestsQueueMutex.RUnlock()
	return len(fake.processSubscriptionRequestsQueueArgsForCall)
}

func (fake *FakeLocalParticipant) ProcessSubscriptionRequestsQueueCalls(stub func(livekit.TrackID)) {
	fake.processSubscriptionRequestsQueueMutex.Lock()
	defer fake.processSubscriptionRequestsQueueMutex.Unlock()
	fake.ProcessSubscriptionRequestsQueueStub = stub
}

func (fake *FakeLocalParticipant) ProcessSubscriptionRequestsQueueArgsForCall(i int) livekit.TrackID {
	fake.processSubscriptionRequestsQueueMutex.RLock()
	defer fake.processSubscriptionRequestsQueueMutex.RUnlock()
	argsForCall := fake.processSubscriptionRequestsQueueArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) ProtocolVersion() types.ProtocolVersion {
	fake.protocolVersionMutex.Lock()
	ret, specificReturn := fake.protocolVersionReturnsOnCall[len(fake.protocolVersionArgsForCall)]
	fake.protocolVersionArgsForCall = append(fake.protocolVersionArgsForCall, struct {
	}{})
	stub := fake.ProtocolVersionStub
	fakeReturns := fake.protocolVersionReturns
	fake.recordInvocation("ProtocolVersion", []interface{}{})
	fake.protocolVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) ProtocolVersionCallCount() int {
	fake.protocolVersionMutex.RLock()
	defer fake.protocolVersionMutex.RUnlock()
	return len(fake.protocolVersionArgsForCall)
}

func (fake *FakeLocalParticipant) ProtocolVersionCalls(stub func() types.ProtocolVersion) {
	fake.protocolVersionMutex.Lock()
	defer fake.protocolVersionMutex.Unlock()
	fake.ProtocolVersionStub = stub
}

func (fake *FakeLocalParticipant) ProtocolVersionReturns(result1 types.ProtocolVersion) {
	fake.protocolVersionMutex.Lock()
	defer fake.protocolVersionMutex.Unlock()
	fake.ProtocolVersionStub = nil
	fake.protocolVersionReturns = struct {
		result1 types.ProtocolVersion
	}{result1}
}

func (fake *FakeLocalParticipant) ProtocolVersionReturnsOnCall(i int, result1 types.ProtocolVersion) {
	fake.protocolVersionMutex.Lock()
	defer fake.protocolVersionMutex.Unlock()
	fake.ProtocolVersionStub = nil
	if fake.protocolVersionReturnsOnCall == nil {
		fake.protocolVersionReturnsOnCall = make(map[int]struct {
			result1 types.ProtocolVersion
		})
	}
	fake.protocolVersionReturnsOnCall[i] = struct {
		result1 types.ProtocolVersion
	}{result1}
}

func (fake *FakeLocalParticipant) RemovePublishedTrack(arg1 types.MediaTrack, arg2 bool, arg3 bool) {
	fake.removePublishedTrackMutex.Lock()
	fake.removePublishedTrackArgsForCall = append(fake.removePublishedTrackArgsForCall, struct {
		arg1 types.MediaTrack
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.RemovePublishedTrackStub
	fake.recordInvocation("RemovePublishedTrack", []interface{}{arg1, arg2, arg3})
	fake.removePublishedTrackMutex.Unlock()
	if stub != nil {
		fake.RemovePublishedTrackStub(arg1, arg2, arg3)
	}
}

func (fake *FakeLocalParticipant) RemovePublishedTrackCallCount() int {
	fake.removePublishedTrackMutex.RLock()
	defer fake.removePublishedTrackMutex.RUnlock()
	return len(fake.removePublishedTrackArgsForCall)
}

func (fake *FakeLocalParticipant) RemovePublishedTrackCalls(stub func(types.MediaTrack, bool, bool)) {
	fake.removePublishedTrackMutex.Lock()
	defer fake.removePublishedTrackMutex.Unlock()
	fake.RemovePublishedTrackStub = stub
}

func (fake *FakeLocalParticipant) RemovePublishedTrackArgsForCall(i int) (types.MediaTrack, bool, bool) {
	fake.removePublishedTrackMutex.RLock()
	defer fake.removePublishedTrackMutex.RUnlock()
	argsForCall := fake.removePublishedTrackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLocalParticipant) RemoveSubscribedTrack(arg1 types.SubscribedTrack) {
	fake.removeSubscribedTrackMutex.Lock()
	fake.removeSubscribedTrackArgsForCall = append(fake.removeSubscribedTrackArgsForCall, struct {
		arg1 types.SubscribedTrack
	}{arg1})
	stub := fake.RemoveSubscribedTrackStub
	fake.recordInvocation("RemoveSubscribedTrack", []interface{}{arg1})
	fake.removeSubscribedTrackMutex.Unlock()
	if stub != nil {
		fake.RemoveSubscribedTrackStub(arg1)
	}
}

func (fake *FakeLocalParticipant) RemoveSubscribedTrackCallCount() int {
	fake.removeSubscribedTrackMutex.RLock()
	defer fake.removeSubscribedTrackMutex.RUnlock()
	return len(fake.removeSubscribedTrackArgsForCall)
}

func (fake *FakeLocalParticipant) RemoveSubscribedTrackCalls(stub func(types.SubscribedTrack)) {
	fake.removeSubscribedTrackMutex.Lock()
	defer fake.removeSubscribedTrackMutex.Unlock()
	fake.RemoveSubscribedTrackStub = stub
}

func (fake *FakeLocalParticipant) RemoveSubscribedTrackArgsForCall(i int) types.SubscribedTrack {
	fake.removeSubscribedTrackMutex.RLock()
	defer fake.removeSubscribedTrackMutex.RUnlock()
	argsForCall := fake.removeSubscribedTrackArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) RemoveSubscriber(arg1 types.LocalParticipant, arg2 livekit.TrackID, arg3 bool) {
	fake.removeSubscriberMutex.Lock()
	fake.removeSubscriberArgsForCall = append(fake.removeSubscriberArgsForCall, struct {
		arg1 types.LocalParticipant
		arg2 livekit.TrackID
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.RemoveSubscriberStub
	fake.recordInvocation("RemoveSubscriber", []interface{}{arg1, arg2, arg3})
	fake.removeSubscriberMutex.Unlock()
	if stub != nil {
		fake.RemoveSubscriberStub(arg1, arg2, arg3)
	}
}

func (fake *FakeLocalParticipant) RemoveSubscriberCallCount() int {
	fake.removeSubscriberMutex.RLock()
	defer fake.removeSubscriberMutex.RUnlock()
	return len(fake.removeSubscriberArgsForCall)
}

func (fake *FakeLocalParticipant) RemoveSubscriberCalls(stub func(types.LocalParticipant, livekit.TrackID, bool)) {
	fake.removeSubscriberMutex.Lock()
	defer fake.removeSubscriberMutex.Unlock()
	fake.RemoveSubscriberStub = stub
}

func (fake *FakeLocalParticipant) RemoveSubscriberArgsForCall(i int) (types.LocalParticipant, livekit.TrackID, bool) {
	fake.removeSubscriberMutex.RLock()
	defer fake.removeSubscriberMutex.RUnlock()
	argsForCall := fake.removeSubscriberArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLocalParticipant) RemoveTrackFromSubscriber(arg1 *webrtc.RTPSender) error {
	fake.removeTrackFromSubscriberMutex.Lock()
	ret, specificReturn := fake.removeTrackFromSubscriberReturnsOnCall[len(fake.removeTrackFromSubscriberArgsForCall)]
	fake.removeTrackFromSubscriberArgsForCall = append(fake.removeTrackFromSubscriberArgsForCall, struct {
		arg1 *webrtc.RTPSender
	}{arg1})
	stub := fake.RemoveTrackFromSubscriberStub
	fakeReturns := fake.removeTrackFromSubscriberReturns
	fake.recordInvocation("RemoveTrackFromSubscriber", []interface{}{arg1})
	fake.removeTrackFromSubscriberMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) RemoveTrackFromSubscriberCallCount() int {
	fake.removeTrackFromSubscriberMutex.RLock()
	defer fake.removeTrackFromSubscriberMutex.RUnlock()
	return len(fake.removeTrackFromSubscriberArgsForCall)
}

func (fake *FakeLocalParticipant) RemoveTrackFromSubscriberCalls(stub func(*webrtc.RTPSender) error) {
	fake.removeTrackFromSubscriberMutex.Lock()
	defer fake.removeTrackFromSubscriberMutex.Unlock()
	fake.RemoveTrackFromSubscriberStub = stub
}

func (fake *FakeLocalParticipant) RemoveTrackFromSubscriberArgsForCall(i int) *webrtc.RTPSender {
	fake.removeTrackFromSubscriberMutex.RLock()
	defer fake.removeTrackFromSubscriberMutex.RUnlock()
	argsForCall := fake.removeTrackFromSubscriberArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) RemoveTrackFromSubscriberReturns(result1 error) {
	fake.removeTrackFromSubscriberMutex.Lock()
	defer fake.removeTrackFromSubscriberMutex.Unlock()
	fake.RemoveTrackFromSubscriberStub = nil
	fake.removeTrackFromSubscriberReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) RemoveTrackFromSubscriberReturnsOnCall(i int, result1 error) {
	fake.removeTrackFromSubscriberMutex.Lock()
	defer fake.removeTrackFromSubscriberMutex.Unlock()
	fake.RemoveTrackFromSubscriberStub = nil
	if fake.removeTrackFromSubscriberReturnsOnCall == nil {
		fake.removeTrackFromSubscriberReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeTrackFromSubscriberReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) SendConnectionQualityUpdate(arg1 *livekit.ConnectionQualityUpdate) error {
	fake.sendConnectionQualityUpdateMutex.Lock()
	ret, specificReturn := fake.sendConnectionQualityUpdateReturnsOnCall[len(fake.sendConnectionQualityUpdateArgsForCall)]
	fake.sendConnectionQualityUpdateArgsForCall = append(fake.sendConnectionQualityUpdateArgsForCall, struct {
		arg1 *livekit.ConnectionQualityUpdate
	}{arg1})
	stub := fake.SendConnectionQualityUpdateStub
	fakeReturns := fake.sendConnectionQualityUpdateReturns
	fake.recordInvocation("SendConnectionQualityUpdate", []interface{}{arg1})
	fake.sendConnectionQualityUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) SendConnectionQualityUpdateCallCount() int {
	fake.sendConnectionQualityUpdateMutex.RLock()
	defer fake.sendConnectionQualityUpdateMutex.RUnlock()
	return len(fake.sendConnectionQualityUpdateArgsForCall)
}

func (fake *FakeLocalParticipant) SendConnectionQualityUpdateCalls(stub func(*livekit.ConnectionQualityUpdate) error) {
	fake.sendConnectionQualityUpdateMutex.Lock()
	defer fake.sendConnectionQualityUpdateMutex.Unlock()
	fake.SendConnectionQualityUpdateStub = stub
}

func (fake *FakeLocalParticipant) SendConnectionQualityUpdateArgsForCall(i int) *livekit.ConnectionQualityUpdate {
	fake.sendConnectionQualityUpdateMutex.RLock()
	defer fake.sendConnectionQualityUpdateMutex.RUnlock()
	argsForCall := fake.sendConnectionQualityUpdateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) SendConnectionQualityUpdateReturns(result1 error) {
	fake.sendConnectionQualityUpdateMutex.Lock()
	defer fake.sendConnectionQualityUpdateMutex.Unlock()
	fake.SendConnectionQualityUpdateStub = nil
	fake.sendConnectionQualityUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) SendConnectionQualityUpdateReturnsOnCall(i int, result1 error) {
	fake.sendConnectionQualityUpdateMutex.Lock()
	defer fake.sendConnectionQualityUpdateMutex.Unlock()
	fake.SendConnectionQualityUpdateStub = nil
	if fake.sendConnectionQualityUpdateReturnsOnCall == nil {
		fake.sendConnectionQualityUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendConnectionQualityUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) SendDataPacket(arg1 *livekit.DataPacket) error {
	fake.sendDataPacketMutex.Lock()
	ret, specificReturn := fake.sendDataPacketReturnsOnCall[len(fake.sendDataPacketArgsForCall)]
	fake.sendDataPacketArgsForCall = append(fake.sendDataPacketArgsForCall, struct {
		arg1 *livekit.DataPacket
	}{arg1})
	stub := fake.SendDataPacketStub
	fakeReturns := fake.sendDataPacketReturns
	fake.recordInvocation("SendDataPacket", []interface{}{arg1})
	fake.sendDataPacketMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) SendDataPacketCallCount() int {
	fake.sendDataPacketMutex.RLock()
	defer fake.sendDataPacketMutex.RUnlock()
	return len(fake.sendDataPacketArgsForCall)
}

func (fake *FakeLocalParticipant) SendDataPacketCalls(stub func(*livekit.DataPacket) error) {
	fake.sendDataPacketMutex.Lock()
	defer fake.sendDataPacketMutex.Unlock()
	fake.SendDataPacketStub = stub
}

func (fake *FakeLocalParticipant) SendDataPacketArgsForCall(i int) *livekit.DataPacket {
	fake.sendDataPacketMutex.RLock()
	defer fake.sendDataPacketMutex.RUnlock()
	argsForCall := fake.sendDataPacketArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) SendDataPacketReturns(result1 error) {
	fake.sendDataPacketMutex.Lock()
	defer fake.sendDataPacketMutex.Unlock()
	fake.SendDataPacketStub = nil
	fake.sendDataPacketReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) SendDataPacketReturnsOnCall(i int, result1 error) {
	fake.sendDataPacketMutex.Lock()
	defer fake.sendDataPacketMutex.Unlock()
	fake.SendDataPacketStub = nil
	if fake.sendDataPacketReturnsOnCall == nil {
		fake.sendDataPacketReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendDataPacketReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) SendJoinResponse(arg1 *livekit.JoinResponse) error {
	fake.sendJoinResponseMutex.Lock()
	ret, specificReturn := fake.sendJoinResponseReturnsOnCall[len(fake.sendJoinResponseArgsForCall)]
	fake.sendJoinResponseArgsForCall = append(fake.sendJoinResponseArgsForCall, struct {
		arg1 *livekit.JoinResponse
	}{arg1})
	stub := fake.SendJoinResponseStub
	fakeReturns := fake.sendJoinResponseReturns
	fake.recordInvocation("SendJoinResponse", []interface{}{arg1})
	fake.sendJoinResponseMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) SendJoinResponseCallCount() int {
	fake.sendJoinResponseMutex.RLock()
	defer fake.sendJoinResponseMutex.RUnlock()
	return len(fake.sendJoinResponseArgsForCall)
}

func (fake *FakeLocalParticipant) SendJoinResponseCalls(stub func(*livekit.JoinResponse) error) {
	fake.sendJoinResponseMutex.Lock()
	defer fake.sendJoinResponseMutex.Unlock()
	fake.SendJoinResponseStub = stub
}

func (fake *FakeLocalParticipant) SendJoinResponseArgsForCall(i int) *livekit.JoinResponse {
	fake.sendJoinResponseMutex.RLock()
	defer fake.sendJoinResponseMutex.RUnlock()
	argsForCall := fake.sendJoinResponseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) SendJoinResponseReturns(result1 error) {
	fake.sendJoinResponseMutex.Lock()
	defer fake.sendJoinResponseMutex.Unlock()
	fake.SendJoinResponseStub = nil
	fake.sendJoinResponseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) SendJoinResponseReturnsOnCall(i int, result1 error) {
	fake.sendJoinResponseMutex.Lock()
	defer fake.sendJoinResponseMutex.Unlock()
	fake.SendJoinResponseStub = nil
	if fake.sendJoinResponseReturnsOnCall == nil {
		fake.sendJoinResponseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendJoinResponseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) SendParticipantUpdate(arg1 []*livekit.ParticipantInfo) error {
	var arg1Copy []*livekit.ParticipantInfo
	if arg1 != nil {
		arg1Copy = make([]*livekit.ParticipantInfo, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.sendParticipantUpdateMutex.Lock()
	ret, specificReturn := fake.sendParticipantUpdateReturnsOnCall[len(fake.sendParticipantUpdateArgsForCall)]
	fake.sendParticipantUpdateArgsForCall = append(fake.sendParticipantUpdateArgsForCall, struct {
		arg1 []*livekit.ParticipantInfo
	}{arg1Copy})
	stub := fake.SendParticipantUpdateStub
	fakeReturns := fake.sendParticipantUpdateReturns
	fake.recordInvocation("SendParticipantUpdate", []interface{}{arg1Copy})
	fake.sendParticipantUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) SendParticipantUpdateCallCount() int {
	fake.sendParticipantUpdateMutex.RLock()
	defer fake.sendParticipantUpdateMutex.RUnlock()
	return len(fake.sendParticipantUpdateArgsForCall)
}

func (fake *FakeLocalParticipant) SendParticipantUpdateCalls(stub func([]*livekit.ParticipantInfo) error) {
	fake.sendParticipantUpdateMutex.Lock()
	defer fake.sendParticipantUpdateMutex.Unlock()
	fake.SendParticipantUpdateStub = stub
}

func (fake *FakeLocalParticipant) SendParticipantUpdateArgsForCall(i int) []*livekit.ParticipantInfo {
	fake.sendParticipantUpdateMutex.RLock()
	defer fake.sendParticipantUpdateMutex.RUnlock()
	argsForCall := fake.sendParticipantUpdateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) SendParticipantUpdateReturns(result1 error) {
	fake.sendParticipantUpdateMutex.Lock()
	defer fake.sendParticipantUpdateMutex.Unlock()
	fake.SendParticipantUpdateStub = nil
	fake.sendParticipantUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) SendParticipantUpdateReturnsOnCall(i int, result1 error) {
	fake.sendParticipantUpdateMutex.Lock()
	defer fake.sendParticipantUpdateMutex.Unlock()
	fake.SendParticipantUpdateStub = nil
	if fake.sendParticipantUpdateReturnsOnCall == nil {
		fake.sendParticipantUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendParticipantUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) SendRefreshToken(arg1 string) error {
	fake.sendRefreshTokenMutex.Lock()
	ret, specificReturn := fake.sendRefreshTokenReturnsOnCall[len(fake.sendRefreshTokenArgsForCall)]
	fake.sendRefreshTokenArgsForCall = append(fake.sendRefreshTokenArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SendRefreshTokenStub
	fakeReturns := fake.sendRefreshTokenReturns
	fake.recordInvocation("SendRefreshToken", []interface{}{arg1})
	fake.sendRefreshTokenMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) SendRefreshTokenCallCount() int {
	fake.sendRefreshTokenMutex.RLock()
	defer fake.sendRefreshTokenMutex.RUnlock()
	return len(fake.sendRefreshTokenArgsForCall)
}

func (fake *FakeLocalParticipant) SendRefreshTokenCalls(stub func(string) error) {
	fake.sendRefreshTokenMutex.Lock()
	defer fake.sendRefreshTokenMutex.Unlock()
	fake.SendRefreshTokenStub = stub
}

func (fake *FakeLocalParticipant) SendRefreshTokenArgsForCall(i int) string {
	fake.sendRefreshTokenMutex.RLock()
	defer fake.sendRefreshTokenMutex.RUnlock()
	argsForCall := fake.sendRefreshTokenArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) SendRefreshTokenReturns(result1 error) {
	fake.sendRefreshTokenMutex.Lock()
	defer fake.sendRefreshTokenMutex.Unlock()
	fake.SendRefreshTokenStub = nil
	fake.sendRefreshTokenReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) SendRefreshTokenReturnsOnCall(i int, result1 error) {
	fake.sendRefreshTokenMutex.Lock()
	defer fake.sendRefreshTokenMutex.Unlock()
	fake.SendRefreshTokenStub = nil
	if fake.sendRefreshTokenReturnsOnCall == nil {
		fake.sendRefreshTokenReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendRefreshTokenReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) SendRoomUpdate(arg1 *livekit.Room) error {
	fake.sendRoomUpdateMutex.Lock()
	ret, specificReturn := fake.sendRoomUpdateReturnsOnCall[len(fake.sendRoomUpdateArgsForCall)]
	fake.sendRoomUpdateArgsForCall = append(fake.sendRoomUpdateArgsForCall, struct {
		arg1 *livekit.Room
	}{arg1})
	stub := fake.SendRoomUpdateStub
	fakeReturns := fake.sendRoomUpdateReturns
	fake.recordInvocation("SendRoomUpdate", []interface{}{arg1})
	fake.sendRoomUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) SendRoomUpdateCallCount() int {
	fake.sendRoomUpdateMutex.RLock()
	defer fake.sendRoomUpdateMutex.RUnlock()
	return len(fake.sendRoomUpdateArgsForCall)
}

func (fake *FakeLocalParticipant) SendRoomUpdateCalls(stub func(*livekit.Room) error) {
	fake.sendRoomUpdateMutex.Lock()
	defer fake.sendRoomUpdateMutex.Unlock()
	fake.SendRoomUpdateStub = stub
}

func (fake *FakeLocalParticipant) SendRoomUpdateArgsForCall(i int) *livekit.Room {
	fake.sendRoomUpdateMutex.RLock()
	defer fake.sendRoomUpdateMutex.RUnlock()
	argsForCall := fake.sendRoomUpdateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) SendRoomUpdateReturns(result1 error) {
	fake.sendRoomUpdateMutex.Lock()
	defer fake.sendRoomUpdateMutex.Unlock()
	fake.SendRoomUpdateStub = nil
	fake.sendRoomUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) SendRoomUpdateReturnsOnCall(i int, result1 error) {
	fake.sendRoomUpdateMutex.Lock()
	defer fake.sendRoomUpdateMutex.Unlock()
	fake.SendRoomUpdateStub = nil
	if fake.sendRoomUpdateReturnsOnCall == nil {
		fake.sendRoomUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendRoomUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) SendSpeakerUpdate(arg1 []*livekit.SpeakerInfo) error {
	var arg1Copy []*livekit.SpeakerInfo
	if arg1 != nil {
		arg1Copy = make([]*livekit.SpeakerInfo, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.sendSpeakerUpdateMutex.Lock()
	ret, specificReturn := fake.sendSpeakerUpdateReturnsOnCall[len(fake.sendSpeakerUpdateArgsForCall)]
	fake.sendSpeakerUpdateArgsForCall = append(fake.sendSpeakerUpdateArgsForCall, struct {
		arg1 []*livekit.SpeakerInfo
	}{arg1Copy})
	stub := fake.SendSpeakerUpdateStub
	fakeReturns := fake.sendSpeakerUpdateReturns
	fake.recordInvocation("SendSpeakerUpdate", []interface{}{arg1Copy})
	fake.sendSpeakerUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) SendSpeakerUpdateCallCount() int {
	fake.sendSpeakerUpdateMutex.RLock()
	defer fake.sendSpeakerUpdateMutex.RUnlock()
	return len(fake.sendSpeakerUpdateArgsForCall)
}

func (fake *FakeLocalParticipant) SendSpeakerUpdateCalls(stub func([]*livekit.SpeakerInfo) error) {
	fake.sendSpeakerUpdateMutex.Lock()
	defer fake.sendSpeakerUpdateMutex.Unlock()
	fake.SendSpeakerUpdateStub = stub
}

func (fake *FakeLocalParticipant) SendSpeakerUpdateArgsForCall(i int) []*livekit.SpeakerInfo {
	fake.sendSpeakerUpdateMutex.RLock()
	defer fake.sendSpeakerUpdateMutex.RUnlock()
	argsForCall := fake.sendSpeakerUpdateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) SendSpeakerUpdateReturns(result1 error) {
	fake.sendSpeakerUpdateMutex.Lock()
	defer fake.sendSpeakerUpdateMutex.Unlock()
	fake.SendSpeakerUpdateStub = nil
	fake.sendSpeakerUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) SendSpeakerUpdateReturnsOnCall(i int, result1 error) {
	fake.sendSpeakerUpdateMutex.Lock()
	defer fake.sendSpeakerUpdateMutex.Unlock()
	fake.SendSpeakerUpdateStub = nil
	if fake.sendSpeakerUpdateReturnsOnCall == nil {
		fake.sendSpeakerUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendSpeakerUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) SetICEConfig(arg1 types.IceConfig) {
	fake.setICEConfigMutex.Lock()
	fake.setICEConfigArgsForCall = append(fake.setICEConfigArgsForCall, struct {
		arg1 types.IceConfig
	}{arg1})
	stub := fake.SetICEConfigStub
	fake.recordInvocation("SetICEConfig", []interface{}{arg1})
	fake.setICEConfigMutex.Unlock()
	if stub != nil {
		fake.SetICEConfigStub(arg1)
	}
}

func (fake *FakeLocalParticipant) SetICEConfigCallCount() int {
	fake.setICEConfigMutex.RLock()
	defer fake.setICEConfigMutex.RUnlock()
	return len(fake.setICEConfigArgsForCall)
}

func (fake *FakeLocalParticipant) SetICEConfigCalls(stub func(types.IceConfig)) {
	fake.setICEConfigMutex.Lock()
	defer fake.setICEConfigMutex.Unlock()
	fake.SetICEConfigStub = stub
}

func (fake *FakeLocalParticipant) SetICEConfigArgsForCall(i int) types.IceConfig {
	fake.setICEConfigMutex.RLock()
	defer fake.setICEConfigMutex.RUnlock()
	argsForCall := fake.setICEConfigArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) SetMetadata(arg1 string) {
	fake.setMetadataMutex.Lock()
	fake.setMetadataArgsForCall = append(fake.setMetadataArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetMetadataStub
	fake.recordInvocation("SetMetadata", []interface{}{arg1})
	fake.setMetadataMutex.Unlock()
	if stub != nil {
		fake.SetMetadataStub(arg1)
	}
}

func (fake *FakeLocalParticipant) SetMetadataCallCount() int {
	fake.setMetadataMutex.RLock()
	defer fake.setMetadataMutex.RUnlock()
	return len(fake.setMetadataArgsForCall)
}

func (fake *FakeLocalParticipant) SetMetadataCalls(stub func(string)) {
	fake.setMetadataMutex.Lock()
	defer fake.setMetadataMutex.Unlock()
	fake.SetMetadataStub = stub
}

func (fake *FakeLocalParticipant) SetMetadataArgsForCall(i int) string {
	fake.setMetadataMutex.RLock()
	defer fake.setMetadataMutex.RUnlock()
	argsForCall := fake.setMetadataArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) SetMigrateInfo(arg1 *webrtc.SessionDescription, arg2 *webrtc.SessionDescription, arg3 []*livekit.TrackPublishedResponse, arg4 []*livekit.DataChannelInfo) {
	var arg3Copy []*livekit.TrackPublishedResponse
	if arg3 != nil {
		arg3Copy = make([]*livekit.TrackPublishedResponse, len(arg3))
		copy(arg3Copy, arg3)
	}
	var arg4Copy []*livekit.DataChannelInfo
	if arg4 != nil {
		arg4Copy = make([]*livekit.DataChannelInfo, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.setMigrateInfoMutex.Lock()
	fake.setMigrateInfoArgsForCall = append(fake.setMigrateInfoArgsForCall, struct {
		arg1 *webrtc.SessionDescription
		arg2 *webrtc.SessionDescription
		arg3 []*livekit.TrackPublishedResponse
		arg4 []*livekit.DataChannelInfo
	}{arg1, arg2, arg3Copy, arg4Copy})
	stub := fake.SetMigrateInfoStub
	fake.recordInvocation("SetMigrateInfo", []interface{}{arg1, arg2, arg3Copy, arg4Copy})
	fake.setMigrateInfoMutex.Unlock()
	if stub != nil {
		fake.SetMigrateInfoStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeLocalParticipant) SetMigrateInfoCallCount() int {
	fake.setMigrateInfoMutex.RLock()
	defer fake.setMigrateInfoMutex.RUnlock()
	return len(fake.setMigrateInfoArgsForCall)
}

func (fake *FakeLocalParticipant) SetMigrateInfoCalls(stub func(*webrtc.SessionDescription, *webrtc.SessionDescription, []*livekit.TrackPublishedResponse, []*livekit.DataChannelInfo)) {
	fake.setMigrateInfoMutex.Lock()
	defer fake.setMigrateInfoMutex.Unlock()
	fake.SetMigrateInfoStub = stub
}

func (fake *FakeLocalParticipant) SetMigrateInfoArgsForCall(i int) (*webrtc.SessionDescription, *webrtc.SessionDescription, []*livekit.TrackPublishedResponse, []*livekit.DataChannelInfo) {
	fake.setMigrateInfoMutex.RLock()
	defer fake.setMigrateInfoMutex.RUnlock()
	argsForCall := fake.setMigrateInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeLocalParticipant) SetMigrateState(arg1 types.MigrateState) {
	fake.setMigrateStateMutex.Lock()
	fake.setMigrateStateArgsForCall = append(fake.setMigrateStateArgsForCall, struct {
		arg1 types.MigrateState
	}{arg1})
	stub := fake.SetMigrateStateStub
	fake.recordInvocation("SetMigrateState", []interface{}{arg1})
	fake.setMigrateStateMutex.Unlock()
	if stub != nil {
		fake.SetMigrateStateStub(arg1)
	}
}

func (fake *FakeLocalParticipant) SetMigrateStateCallCount() int {
	fake.setMigrateStateMutex.RLock()
	defer fake.setMigrateStateMutex.RUnlock()
	return len(fake.setMigrateStateArgsForCall)
}

func (fake *FakeLocalParticipant) SetMigrateStateCalls(stub func(types.MigrateState)) {
	fake.setMigrateStateMutex.Lock()
	defer fake.setMigrateStateMutex.Unlock()
	fake.SetMigrateStateStub = stub
}

func (fake *FakeLocalParticipant) SetMigrateStateArgsForCall(i int) types.MigrateState {
	fake.setMigrateStateMutex.RLock()
	defer fake.setMigrateStateMutex.RUnlock()
	argsForCall := fake.setMigrateStateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) SetPermission(arg1 *livekit.ParticipantPermission) bool {
	fake.setPermissionMutex.Lock()
	ret, specificReturn := fake.setPermissionReturnsOnCall[len(fake.setPermissionArgsForCall)]
	fake.setPermissionArgsForCall = append(fake.setPermissionArgsForCall, struct {
		arg1 *livekit.ParticipantPermission
	}{arg1})
	stub := fake.SetPermissionStub
	fakeReturns := fake.setPermissionReturns
	fake.recordInvocation("SetPermission", []interface{}{arg1})
	fake.setPermissionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) SetPermissionCallCount() int {
	fake.setPermissionMutex.RLock()
	defer fake.setPermissionMutex.RUnlock()
	return len(fake.setPermissionArgsForCall)
}

func (fake *FakeLocalParticipant) SetPermissionCalls(stub func(*livekit.ParticipantPermission) bool) {
	fake.setPermissionMutex.Lock()
	defer fake.setPermissionMutex.Unlock()
	fake.SetPermissionStub = stub
}

func (fake *FakeLocalParticipant) SetPermissionArgsForCall(i int) *livekit.ParticipantPermission {
	fake.setPermissionMutex.RLock()
	defer fake.setPermissionMutex.RUnlock()
	argsForCall := fake.setPermissionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) SetPermissionReturns(result1 bool) {
	fake.setPermissionMutex.Lock()
	defer fake.setPermissionMutex.Unlock()
	fake.SetPermissionStub = nil
	fake.setPermissionReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) SetPermissionReturnsOnCall(i int, result1 bool) {
	fake.setPermissionMutex.Lock()
	defer fake.setPermissionMutex.Unlock()
	fake.SetPermissionStub = nil
	if fake.setPermissionReturnsOnCall == nil {
		fake.setPermissionReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.setPermissionReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) SetResponseSink(arg1 routing.MessageSink) {
	fake.setResponseSinkMutex.Lock()
	fake.setResponseSinkArgsForCall = append(fake.setResponseSinkArgsForCall, struct {
		arg1 routing.MessageSink
	}{arg1})
	stub := fake.SetResponseSinkStub
	fake.recordInvocation("SetResponseSink", []interface{}{arg1})
	fake.setResponseSinkMutex.Unlock()
	if stub != nil {
		fake.SetResponseSinkStub(arg1)
	}
}

func (fake *FakeLocalParticipant) SetResponseSinkCallCount() int {
	fake.setResponseSinkMutex.RLock()
	defer fake.setResponseSinkMutex.RUnlock()
	return len(fake.setResponseSinkArgsForCall)
}

func (fake *FakeLocalParticipant) SetResponseSinkCalls(stub func(routing.MessageSink)) {
	fake.setResponseSinkMutex.Lock()
	defer fake.setResponseSinkMutex.Unlock()
	fake.SetResponseSinkStub = stub
}

func (fake *FakeLocalParticipant) SetResponseSinkArgsForCall(i int) routing.MessageSink {
	fake.setResponseSinkMutex.RLock()
	defer fake.setResponseSinkMutex.RUnlock()
	argsForCall := fake.setResponseSinkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) SetTrackMuted(arg1 livekit.TrackID, arg2 bool, arg3 bool) {
	fake.setTrackMutedMutex.Lock()
	fake.setTrackMutedArgsForCall = append(fake.setTrackMutedArgsForCall, struct {
		arg1 livekit.TrackID
		arg2 bool
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.SetTrackMutedStub
	fake.recordInvocation("SetTrackMuted", []interface{}{arg1, arg2, arg3})
	fake.setTrackMutedMutex.Unlock()
	if stub != nil {
		fake.SetTrackMutedStub(arg1, arg2, arg3)
	}
}

func (fake *FakeLocalParticipant) SetTrackMutedCallCount() int {
	fake.setTrackMutedMutex.RLock()
	defer fake.setTrackMutedMutex.RUnlock()
	return len(fake.setTrackMutedArgsForCall)
}

func (fake *FakeLocalParticipant) SetTrackMutedCalls(stub func(livekit.TrackID, bool, bool)) {
	fake.setTrackMutedMutex.Lock()
	defer fake.setTrackMutedMutex.Unlock()
	fake.SetTrackMutedStub = stub
}

func (fake *FakeLocalParticipant) SetTrackMutedArgsForCall(i int) (livekit.TrackID, bool, bool) {
	fake.setTrackMutedMutex.RLock()
	defer fake.setTrackMutedMutex.RUnlock()
	argsForCall := fake.setTrackMutedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLocalParticipant) Start() {
	fake.startMutex.Lock()
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
	}{})
	stub := fake.StartStub
	fake.recordInvocation("Start", []interface{}{})
	fake.startMutex.Unlock()
	if stub != nil {
		fake.StartStub()
	}
}

func (fake *FakeLocalParticipant) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeLocalParticipant) StartCalls(stub func()) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = stub
}

func (fake *FakeLocalParticipant) State() livekit.ParticipantInfo_State {
	fake.stateMutex.Lock()
	ret, specificReturn := fake.stateReturnsOnCall[len(fake.stateArgsForCall)]
	fake.stateArgsForCall = append(fake.stateArgsForCall, struct {
	}{})
	stub := fake.StateStub
	fakeReturns := fake.stateReturns
	fake.recordInvocation("State", []interface{}{})
	fake.stateMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) StateCallCount() int {
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	return len(fake.stateArgsForCall)
}

func (fake *FakeLocalParticipant) StateCalls(stub func() livekit.ParticipantInfo_State) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = stub
}

func (fake *FakeLocalParticipant) StateReturns(result1 livekit.ParticipantInfo_State) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = nil
	fake.stateReturns = struct {
		result1 livekit.ParticipantInfo_State
	}{result1}
}

func (fake *FakeLocalParticipant) StateReturnsOnCall(i int, result1 livekit.ParticipantInfo_State) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = nil
	if fake.stateReturnsOnCall == nil {
		fake.stateReturnsOnCall = make(map[int]struct {
			result1 livekit.ParticipantInfo_State
		})
	}
	fake.stateReturnsOnCall[i] = struct {
		result1 livekit.ParticipantInfo_State
	}{result1}
}

func (fake *FakeLocalParticipant) SubscriberAsPrimary() bool {
	fake.subscriberAsPrimaryMutex.Lock()
	ret, specificReturn := fake.subscriberAsPrimaryReturnsOnCall[len(fake.subscriberAsPrimaryArgsForCall)]
	fake.subscriberAsPrimaryArgsForCall = append(fake.subscriberAsPrimaryArgsForCall, struct {
	}{})
	stub := fake.SubscriberAsPrimaryStub
	fakeReturns := fake.subscriberAsPrimaryReturns
	fake.recordInvocation("SubscriberAsPrimary", []interface{}{})
	fake.subscriberAsPrimaryMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) SubscriberAsPrimaryCallCount() int {
	fake.subscriberAsPrimaryMutex.RLock()
	defer fake.subscriberAsPrimaryMutex.RUnlock()
	return len(fake.subscriberAsPrimaryArgsForCall)
}

func (fake *FakeLocalParticipant) SubscriberAsPrimaryCalls(stub func() bool) {
	fake.subscriberAsPrimaryMutex.Lock()
	defer fake.subscriberAsPrimaryMutex.Unlock()
	fake.SubscriberAsPrimaryStub = stub
}

func (fake *FakeLocalParticipant) SubscriberAsPrimaryReturns(result1 bool) {
	fake.subscriberAsPrimaryMutex.Lock()
	defer fake.subscriberAsPrimaryMutex.Unlock()
	fake.SubscriberAsPrimaryStub = nil
	fake.subscriberAsPrimaryReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) SubscriberAsPrimaryReturnsOnCall(i int, result1 bool) {
	fake.subscriberAsPrimaryMutex.Lock()
	defer fake.subscriberAsPrimaryMutex.Unlock()
	fake.SubscriberAsPrimaryStub = nil
	if fake.subscriberAsPrimaryReturnsOnCall == nil {
		fake.subscriberAsPrimaryReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.subscriberAsPrimaryReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeLocalParticipant) SubscriptionPermission() (*livekit.SubscriptionPermission, *livekit.TimedVersion) {
	fake.subscriptionPermissionMutex.Lock()
	ret, specificReturn := fake.subscriptionPermissionReturnsOnCall[len(fake.subscriptionPermissionArgsForCall)]
	fake.subscriptionPermissionArgsForCall = append(fake.subscriptionPermissionArgsForCall, struct {
	}{})
	stub := fake.SubscriptionPermissionStub
	fakeReturns := fake.subscriptionPermissionReturns
	fake.recordInvocation("SubscriptionPermission", []interface{}{})
	fake.subscriptionPermissionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeLocalParticipant) SubscriptionPermissionCallCount() int {
	fake.subscriptionPermissionMutex.RLock()
	defer fake.subscriptionPermissionMutex.RUnlock()
	return len(fake.subscriptionPermissionArgsForCall)
}

func (fake *FakeLocalParticipant) SubscriptionPermissionCalls(stub func() (*livekit.SubscriptionPermission, *livekit.TimedVersion)) {
	fake.subscriptionPermissionMutex.Lock()
	defer fake.subscriptionPermissionMutex.Unlock()
	fake.SubscriptionPermissionStub = stub
}

func (fake *FakeLocalParticipant) SubscriptionPermissionReturns(result1 *livekit.SubscriptionPermission, result2 *livekit.TimedVersion) {
	fake.subscriptionPermissionMutex.Lock()
	defer fake.subscriptionPermissionMutex.Unlock()
	fake.SubscriptionPermissionStub = nil
	fake.subscriptionPermissionReturns = struct {
		result1 *livekit.SubscriptionPermission
		result2 *livekit.TimedVersion
	}{result1, result2}
}

func (fake *FakeLocalParticipant) SubscriptionPermissionReturnsOnCall(i int, result1 *livekit.SubscriptionPermission, result2 *livekit.TimedVersion) {
	fake.subscriptionPermissionMutex.Lock()
	defer fake.subscriptionPermissionMutex.Unlock()
	fake.SubscriptionPermissionStub = nil
	if fake.subscriptionPermissionReturnsOnCall == nil {
		fake.subscriptionPermissionReturnsOnCall = make(map[int]struct {
			result1 *livekit.SubscriptionPermission
			result2 *livekit.TimedVersion
		})
	}
	fake.subscriptionPermissionReturnsOnCall[i] = struct {
		result1 *livekit.SubscriptionPermission
		result2 *livekit.TimedVersion
	}{result1, result2}
}

func (fake *FakeLocalParticipant) SubscriptionPermissionUpdate(arg1 livekit.ParticipantID, arg2 livekit.TrackID, arg3 bool) {
	fake.subscriptionPermissionUpdateMutex.Lock()
	fake.subscriptionPermissionUpdateArgsForCall = append(fake.subscriptionPermissionUpdateArgsForCall, struct {
		arg1 livekit.ParticipantID
		arg2 livekit.TrackID
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.SubscriptionPermissionUpdateStub
	fake.recordInvocation("SubscriptionPermissionUpdate", []interface{}{arg1, arg2, arg3})
	fake.subscriptionPermissionUpdateMutex.Unlock()
	if stub != nil {
		fake.SubscriptionPermissionUpdateStub(arg1, arg2, arg3)
	}
}

func (fake *FakeLocalParticipant) SubscriptionPermissionUpdateCallCount() int {
	fake.subscriptionPermissionUpdateMutex.RLock()
	defer fake.subscriptionPermissionUpdateMutex.RUnlock()
	return len(fake.subscriptionPermissionUpdateArgsForCall)
}

func (fake *FakeLocalParticipant) SubscriptionPermissionUpdateCalls(stub func(livekit.ParticipantID, livekit.TrackID, bool)) {
	fake.subscriptionPermissionUpdateMutex.Lock()
	defer fake.subscriptionPermissionUpdateMutex.Unlock()
	fake.SubscriptionPermissionUpdateStub = stub
}

func (fake *FakeLocalParticipant) SubscriptionPermissionUpdateArgsForCall(i int) (livekit.ParticipantID, livekit.TrackID, bool) {
	fake.subscriptionPermissionUpdateMutex.RLock()
	defer fake.subscriptionPermissionUpdateMutex.RUnlock()
	argsForCall := fake.subscriptionPermissionUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLocalParticipant) ToProto() *livekit.ParticipantInfo {
	fake.toProtoMutex.Lock()
	ret, specificReturn := fake.toProtoReturnsOnCall[len(fake.toProtoArgsForCall)]
	fake.toProtoArgsForCall = append(fake.toProtoArgsForCall, struct {
	}{})
	stub := fake.ToProtoStub
	fakeReturns := fake.toProtoReturns
	fake.recordInvocation("ToProto", []interface{}{})
	fake.toProtoMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) ToProtoCallCount() int {
	fake.toProtoMutex.RLock()
	defer fake.toProtoMutex.RUnlock()
	return len(fake.toProtoArgsForCall)
}

func (fake *FakeLocalParticipant) ToProtoCalls(stub func() *livekit.ParticipantInfo) {
	fake.toProtoMutex.Lock()
	defer fake.toProtoMutex.Unlock()
	fake.ToProtoStub = stub
}

func (fake *FakeLocalParticipant) ToProtoReturns(result1 *livekit.ParticipantInfo) {
	fake.toProtoMutex.Lock()
	defer fake.toProtoMutex.Unlock()
	fake.ToProtoStub = nil
	fake.toProtoReturns = struct {
		result1 *livekit.ParticipantInfo
	}{result1}
}

func (fake *FakeLocalParticipant) ToProtoReturnsOnCall(i int, result1 *livekit.ParticipantInfo) {
	fake.toProtoMutex.Lock()
	defer fake.toProtoMutex.Unlock()
	fake.ToProtoStub = nil
	if fake.toProtoReturnsOnCall == nil {
		fake.toProtoReturnsOnCall = make(map[int]struct {
			result1 *livekit.ParticipantInfo
		})
	}
	fake.toProtoReturnsOnCall[i] = struct {
		result1 *livekit.ParticipantInfo
	}{result1}
}

func (fake *FakeLocalParticipant) UncacheDownTrack(arg1 *webrtc.RTPTransceiver) {
	fake.uncacheDownTrackMutex.Lock()
	fake.uncacheDownTrackArgsForCall = append(fake.uncacheDownTrackArgsForCall, struct {
		arg1 *webrtc.RTPTransceiver
	}{arg1})
	stub := fake.UncacheDownTrackStub
	fake.recordInvocation("UncacheDownTrack", []interface{}{arg1})
	fake.uncacheDownTrackMutex.Unlock()
	if stub != nil {
		fake.UncacheDownTrackStub(arg1)
	}
}

func (fake *FakeLocalParticipant) UncacheDownTrackCallCount() int {
	fake.uncacheDownTrackMutex.RLock()
	defer fake.uncacheDownTrackMutex.RUnlock()
	return len(fake.uncacheDownTrackArgsForCall)
}

func (fake *FakeLocalParticipant) UncacheDownTrackCalls(stub func(*webrtc.RTPTransceiver)) {
	fake.uncacheDownTrackMutex.Lock()
	defer fake.uncacheDownTrackMutex.Unlock()
	fake.UncacheDownTrackStub = stub
}

func (fake *FakeLocalParticipant) UncacheDownTrackArgsForCall(i int) *webrtc.RTPTransceiver {
	fake.uncacheDownTrackMutex.RLock()
	defer fake.uncacheDownTrackMutex.RUnlock()
	argsForCall := fake.uncacheDownTrackArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) UpdateMediaLoss(arg1 livekit.NodeID, arg2 livekit.TrackID, arg3 uint32) error {
	fake.updateMediaLossMutex.Lock()
	ret, specificReturn := fake.updateMediaLossReturnsOnCall[len(fake.updateMediaLossArgsForCall)]
	fake.updateMediaLossArgsForCall = append(fake.updateMediaLossArgsForCall, struct {
		arg1 livekit.NodeID
		arg2 livekit.TrackID
		arg3 uint32
	}{arg1, arg2, arg3})
	stub := fake.UpdateMediaLossStub
	fakeReturns := fake.updateMediaLossReturns
	fake.recordInvocation("UpdateMediaLoss", []interface{}{arg1, arg2, arg3})
	fake.updateMediaLossMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) UpdateMediaLossCallCount() int {
	fake.updateMediaLossMutex.RLock()
	defer fake.updateMediaLossMutex.RUnlock()
	return len(fake.updateMediaLossArgsForCall)
}

func (fake *FakeLocalParticipant) UpdateMediaLossCalls(stub func(livekit.NodeID, livekit.TrackID, uint32) error) {
	fake.updateMediaLossMutex.Lock()
	defer fake.updateMediaLossMutex.Unlock()
	fake.UpdateMediaLossStub = stub
}

func (fake *FakeLocalParticipant) UpdateMediaLossArgsForCall(i int) (livekit.NodeID, livekit.TrackID, uint32) {
	fake.updateMediaLossMutex.RLock()
	defer fake.updateMediaLossMutex.RUnlock()
	argsForCall := fake.updateMediaLossArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLocalParticipant) UpdateMediaLossReturns(result1 error) {
	fake.updateMediaLossMutex.Lock()
	defer fake.updateMediaLossMutex.Unlock()
	fake.UpdateMediaLossStub = nil
	fake.updateMediaLossReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) UpdateMediaLossReturnsOnCall(i int, result1 error) {
	fake.updateMediaLossMutex.Lock()
	defer fake.updateMediaLossMutex.Unlock()
	fake.UpdateMediaLossStub = nil
	if fake.updateMediaLossReturnsOnCall == nil {
		fake.updateMediaLossReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateMediaLossReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) UpdateRTT(arg1 uint32) {
	fake.updateRTTMutex.Lock()
	fake.updateRTTArgsForCall = append(fake.updateRTTArgsForCall, struct {
		arg1 uint32
	}{arg1})
	stub := fake.UpdateRTTStub
	fake.recordInvocation("UpdateRTT", []interface{}{arg1})
	fake.updateRTTMutex.Unlock()
	if stub != nil {
		fake.UpdateRTTStub(arg1)
	}
}

func (fake *FakeLocalParticipant) UpdateRTTCallCount() int {
	fake.updateRTTMutex.RLock()
	defer fake.updateRTTMutex.RUnlock()
	return len(fake.updateRTTArgsForCall)
}

func (fake *FakeLocalParticipant) UpdateRTTCalls(stub func(uint32)) {
	fake.updateRTTMutex.Lock()
	defer fake.updateRTTMutex.Unlock()
	fake.UpdateRTTStub = stub
}

func (fake *FakeLocalParticipant) UpdateRTTArgsForCall(i int) uint32 {
	fake.updateRTTMutex.RLock()
	defer fake.updateRTTMutex.RUnlock()
	argsForCall := fake.updateRTTArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) UpdateSubscribedQuality(arg1 livekit.NodeID, arg2 livekit.TrackID, arg3 []types.SubscribedCodecQuality) error {
	var arg3Copy []types.SubscribedCodecQuality
	if arg3 != nil {
		arg3Copy = make([]types.SubscribedCodecQuality, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.updateSubscribedQualityMutex.Lock()
	ret, specificReturn := fake.updateSubscribedQualityReturnsOnCall[len(fake.updateSubscribedQualityArgsForCall)]
	fake.updateSubscribedQualityArgsForCall = append(fake.updateSubscribedQualityArgsForCall, struct {
		arg1 livekit.NodeID
		arg2 livekit.TrackID
		arg3 []types.SubscribedCodecQuality
	}{arg1, arg2, arg3Copy})
	stub := fake.UpdateSubscribedQualityStub
	fakeReturns := fake.updateSubscribedQualityReturns
	fake.recordInvocation("UpdateSubscribedQuality", []interface{}{arg1, arg2, arg3Copy})
	fake.updateSubscribedQualityMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) UpdateSubscribedQualityCallCount() int {
	fake.updateSubscribedQualityMutex.RLock()
	defer fake.updateSubscribedQualityMutex.RUnlock()
	return len(fake.updateSubscribedQualityArgsForCall)
}

func (fake *FakeLocalParticipant) UpdateSubscribedQualityCalls(stub func(livekit.NodeID, livekit.TrackID, []types.SubscribedCodecQuality) error) {
	fake.updateSubscribedQualityMutex.Lock()
	defer fake.updateSubscribedQualityMutex.Unlock()
	fake.UpdateSubscribedQualityStub = stub
}

func (fake *FakeLocalParticipant) UpdateSubscribedQualityArgsForCall(i int) (livekit.NodeID, livekit.TrackID, []types.SubscribedCodecQuality) {
	fake.updateSubscribedQualityMutex.RLock()
	defer fake.updateSubscribedQualityMutex.RUnlock()
	argsForCall := fake.updateSubscribedQualityArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLocalParticipant) UpdateSubscribedQualityReturns(result1 error) {
	fake.updateSubscribedQualityMutex.Lock()
	defer fake.updateSubscribedQualityMutex.Unlock()
	fake.UpdateSubscribedQualityStub = nil
	fake.updateSubscribedQualityReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) UpdateSubscribedQualityReturnsOnCall(i int, result1 error) {
	fake.updateSubscribedQualityMutex.Lock()
	defer fake.updateSubscribedQualityMutex.Unlock()
	fake.UpdateSubscribedQualityStub = nil
	if fake.updateSubscribedQualityReturnsOnCall == nil {
		fake.updateSubscribedQualityReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateSubscribedQualityReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) UpdateSubscribedTrackSettings(arg1 livekit.TrackID, arg2 *livekit.UpdateTrackSettings) error {
	fake.updateSubscribedTrackSettingsMutex.Lock()
	ret, specificReturn := fake.updateSubscribedTrackSettingsReturnsOnCall[len(fake.updateSubscribedTrackSettingsArgsForCall)]
	fake.updateSubscribedTrackSettingsArgsForCall = append(fake.updateSubscribedTrackSettingsArgsForCall, struct {
		arg1 livekit.TrackID
		arg2 *livekit.UpdateTrackSettings
	}{arg1, arg2})
	stub := fake.UpdateSubscribedTrackSettingsStub
	fakeReturns := fake.updateSubscribedTrackSettingsReturns
	fake.recordInvocation("UpdateSubscribedTrackSettings", []interface{}{arg1, arg2})
	fake.updateSubscribedTrackSettingsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) UpdateSubscribedTrackSettingsCallCount() int {
	fake.updateSubscribedTrackSettingsMutex.RLock()
	defer fake.updateSubscribedTrackSettingsMutex.RUnlock()
	return len(fake.updateSubscribedTrackSettingsArgsForCall)
}

func (fake *FakeLocalParticipant) UpdateSubscribedTrackSettingsCalls(stub func(livekit.TrackID, *livekit.UpdateTrackSettings) error) {
	fake.updateSubscribedTrackSettingsMutex.Lock()
	defer fake.updateSubscribedTrackSettingsMutex.Unlock()
	fake.UpdateSubscribedTrackSettingsStub = stub
}

func (fake *FakeLocalParticipant) UpdateSubscribedTrackSettingsArgsForCall(i int) (livekit.TrackID, *livekit.UpdateTrackSettings) {
	fake.updateSubscribedTrackSettingsMutex.RLock()
	defer fake.updateSubscribedTrackSettingsMutex.RUnlock()
	argsForCall := fake.updateSubscribedTrackSettingsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipant) UpdateSubscribedTrackSettingsReturns(result1 error) {
	fake.updateSubscribedTrackSettingsMutex.Lock()
	defer fake.updateSubscribedTrackSettingsMutex.Unlock()
	fake.UpdateSubscribedTrackSettingsStub = nil
	fake.updateSubscribedTrackSettingsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) UpdateSubscribedTrackSettingsReturnsOnCall(i int, result1 error) {
	fake.updateSubscribedTrackSettingsMutex.Lock()
	defer fake.updateSubscribedTrackSettingsMutex.Unlock()
	fake.UpdateSubscribedTrackSettingsStub = nil
	if fake.updateSubscribedTrackSettingsReturnsOnCall == nil {
		fake.updateSubscribedTrackSettingsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateSubscribedTrackSettingsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) UpdateSubscriptionPermission(arg1 *livekit.SubscriptionPermission, arg2 *livekit.TimedVersion, arg3 func(participantIdentity livekit.ParticipantIdentity) types.LocalParticipant, arg4 func(participantID livekit.ParticipantID) types.LocalParticipant) error {
	fake.updateSubscriptionPermissionMutex.Lock()
	ret, specificReturn := fake.updateSubscriptionPermissionReturnsOnCall[len(fake.updateSubscriptionPermissionArgsForCall)]
	fake.updateSubscriptionPermissionArgsForCall = append(fake.updateSubscriptionPermissionArgsForCall, struct {
		arg1 *livekit.SubscriptionPermission
		arg2 *livekit.TimedVersion
		arg3 func(participantIdentity livekit.ParticipantIdentity) types.LocalParticipant
		arg4 func(participantID livekit.ParticipantID) types.LocalParticipant
	}{arg1, arg2, arg3, arg4})
	stub := fake.UpdateSubscriptionPermissionStub
	fakeReturns := fake.updateSubscriptionPermissionReturns
	fake.recordInvocation("UpdateSubscriptionPermission", []interface{}{arg1, arg2, arg3, arg4})
	fake.updateSubscriptionPermissionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) UpdateSubscriptionPermissionCallCount() int {
	fake.updateSubscriptionPermissionMutex.RLock()
	defer fake.updateSubscriptionPermissionMutex.RUnlock()
	return len(fake.updateSubscriptionPermissionArgsForCall)
}

func (fake *FakeLocalParticipant) UpdateSubscriptionPermissionCalls(stub func(*livekit.SubscriptionPermission, *livekit.TimedVersion, func(participantIdentity livekit.ParticipantIdentity) types.LocalParticipant, func(participantID livekit.ParticipantID) types.LocalParticipant) error) {
	fake.updateSubscriptionPermissionMutex.Lock()
	defer fake.updateSubscriptionPermissionMutex.Unlock()
	fake.UpdateSubscriptionPermissionStub = stub
}

func (fake *FakeLocalParticipant) UpdateSubscriptionPermissionArgsForCall(i int) (*livekit.SubscriptionPermission, *livekit.TimedVersion, func(participantIdentity livekit.ParticipantIdentity) types.LocalParticipant, func(participantID livekit.ParticipantID) types.LocalParticipant) {
	fake.updateSubscriptionPermissionMutex.RLock()
	defer fake.updateSubscriptionPermissionMutex.RUnlock()
	argsForCall := fake.updateSubscriptionPermissionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeLocalParticipant) UpdateSubscriptionPermissionReturns(result1 error) {
	fake.updateSubscriptionPermissionMutex.Lock()
	defer fake.updateSubscriptionPermissionMutex.Unlock()
	fake.UpdateSubscriptionPermissionStub = nil
	fake.updateSubscriptionPermissionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) UpdateSubscriptionPermissionReturnsOnCall(i int, result1 error) {
	fake.updateSubscriptionPermissionMutex.Lock()
	defer fake.updateSubscriptionPermissionMutex.Unlock()
	fake.UpdateSubscriptionPermissionStub = nil
	if fake.updateSubscriptionPermissionReturnsOnCall == nil {
		fake.updateSubscriptionPermissionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateSubscriptionPermissionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) UpdateVideoLayers(arg1 *livekit.UpdateVideoLayers) error {
	fake.updateVideoLayersMutex.Lock()
	ret, specificReturn := fake.updateVideoLayersReturnsOnCall[len(fake.updateVideoLayersArgsForCall)]
	fake.updateVideoLayersArgsForCall = append(fake.updateVideoLayersArgsForCall, struct {
		arg1 *livekit.UpdateVideoLayers
	}{arg1})
	stub := fake.UpdateVideoLayersStub
	fakeReturns := fake.updateVideoLayersReturns
	fake.recordInvocation("UpdateVideoLayers", []interface{}{arg1})
	fake.updateVideoLayersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipant) UpdateVideoLayersCallCount() int {
	fake.updateVideoLayersMutex.RLock()
	defer fake.updateVideoLayersMutex.RUnlock()
	return len(fake.updateVideoLayersArgsForCall)
}

func (fake *FakeLocalParticipant) UpdateVideoLayersCalls(stub func(*livekit.UpdateVideoLayers) error) {
	fake.updateVideoLayersMutex.Lock()
	defer fake.updateVideoLayersMutex.Unlock()
	fake.UpdateVideoLayersStub = stub
}

func (fake *FakeLocalParticipant) UpdateVideoLayersArgsForCall(i int) *livekit.UpdateVideoLayers {
	fake.updateVideoLayersMutex.RLock()
	defer fake.updateVideoLayersMutex.RUnlock()
	argsForCall := fake.updateVideoLayersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipant) UpdateVideoLayersReturns(result1 error) {
	fake.updateVideoLayersMutex.Lock()
	defer fake.updateVideoLayersMutex.Unlock()
	fake.UpdateVideoLayersStub = nil
	fake.updateVideoLayersReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) UpdateVideoLayersReturnsOnCall(i int, result1 error) {
	fake.updateVideoLayersMutex.Lock()
	defer fake.updateVideoLayersMutex.Unlock()
	fake.UpdateVideoLayersStub = nil
	if fake.updateVideoLayersReturnsOnCall == nil {
		fake.updateVideoLayersReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateVideoLayersReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipant) VerifySubscribeParticipantInfo(arg1 livekit.ParticipantID, arg2 uint32) {
	fake.verifySubscribeParticipantInfoMutex.Lock()
	fake.verifySubscribeParticipantInfoArgsForCall = append(fake.verifySubscribeParticipantInfoArgsForCall, struct {
		arg1 livekit.ParticipantID
		arg2 uint32
	}{arg1, arg2})
	stub := fake.VerifySubscribeParticipantInfoStub
	fake.recordInvocation("VerifySubscribeParticipantInfo", []interface{}{arg1, arg2})
	fake.verifySubscribeParticipantInfoMutex.Unlock()
	if stub != nil {
		fake.VerifySubscribeParticipantInfoStub(arg1, arg2)
	}
}

func (fake *FakeLocalParticipant) VerifySubscribeParticipantInfoCallCount() int {
	fake.verifySubscribeParticipantInfoMutex.RLock()
	defer fake.verifySubscribeParticipantInfoMutex.RUnlock()
	return len(fake.verifySubscribeParticipantInfoArgsForCall)
}

func (fake *FakeLocalParticipant) VerifySubscribeParticipantInfoCalls(stub func(livekit.ParticipantID, uint32)) {
	fake.verifySubscribeParticipantInfoMutex.Lock()
	defer fake.verifySubscribeParticipantInfoMutex.Unlock()
	fake.VerifySubscribeParticipantInfoStub = stub
}

func (fake *FakeLocalParticipant) VerifySubscribeParticipantInfoArgsForCall(i int) (livekit.ParticipantID, uint32) {
	fake.verifySubscribeParticipantInfoMutex.RLock()
	defer fake.verifySubscribeParticipantInfoMutex.RUnlock()
	argsForCall := fake.verifySubscribeParticipantInfoArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipant) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addICECandidateMutex.RLock()
	defer fake.addICECandidateMutex.RUnlock()
	fake.addSubscribedTrackMutex.RLock()
	defer fake.addSubscribedTrackMutex.RUnlock()
	fake.addSubscriberMutex.RLock()
	defer fake.addSubscriberMutex.RUnlock()
	fake.addTrackMutex.RLock()
	defer fake.addTrackMutex.RUnlock()
	fake.addTrackToSubscriberMutex.RLock()
	defer fake.addTrackToSubscriberMutex.RUnlock()
	fake.addTransceiverFromTrackToSubscriberMutex.RLock()
	defer fake.addTransceiverFromTrackToSubscriberMutex.RUnlock()
	fake.cacheDownTrackMutex.RLock()
	defer fake.cacheDownTrackMutex.RUnlock()
	fake.canPublishMutex.RLock()
	defer fake.canPublishMutex.RUnlock()
	fake.canPublishDataMutex.RLock()
	defer fake.canPublishDataMutex.RUnlock()
	fake.canSubscribeMutex.RLock()
	defer fake.canSubscribeMutex.RUnlock()
	fake.claimGrantsMutex.RLock()
	defer fake.claimGrantsMutex.RUnlock()
	fake.clearInProgressAndProcessSubscriptionRequestsQueueMutex.RLock()
	defer fake.clearInProgressAndProcessSubscriptionRequestsQueueMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.closeSignalConnectionMutex.RLock()
	defer fake.closeSignalConnectionMutex.RUnlock()
	fake.connectedAtMutex.RLock()
	defer fake.connectedAtMutex.RUnlock()
	fake.debugInfoMutex.RLock()
	defer fake.debugInfoMutex.RUnlock()
	fake.enqueueSubscribeTrackMutex.RLock()
	defer fake.enqueueSubscribeTrackMutex.RUnlock()
	fake.enqueueUnsubscribeTrackMutex.RLock()
	defer fake.enqueueUnsubscribeTrackMutex.RUnlock()
	fake.getAdaptiveStreamMutex.RLock()
	defer fake.getAdaptiveStreamMutex.RUnlock()
	fake.getAudioLevelMutex.RLock()
	defer fake.getAudioLevelMutex.RUnlock()
	fake.getCachedDownTrackMutex.RLock()
	defer fake.getCachedDownTrackMutex.RUnlock()
	fake.getClientConfigurationMutex.RLock()
	defer fake.getClientConfigurationMutex.RUnlock()
	fake.getConnectionQualityMutex.RLock()
	defer fake.getConnectionQualityMutex.RUnlock()
	fake.getICEConnectionTypeMutex.RLock()
	defer fake.getICEConnectionTypeMutex.RUnlock()
	fake.getLoggerMutex.RLock()
	defer fake.getLoggerMutex.RUnlock()
	fake.getPublishedTrackMutex.RLock()
	defer fake.getPublishedTrackMutex.RUnlock()
	fake.getPublishedTracksMutex.RLock()
	defer fake.getPublishedTracksMutex.RUnlock()
	fake.getSubscribedParticipantsMutex.RLock()
	defer fake.getSubscribedParticipantsMutex.RUnlock()
	fake.getSubscribedTracksMutex.RLock()
	defer fake.getSubscribedTracksMutex.RUnlock()
	fake.handleAnswerMutex.RLock()
	defer fake.handleAnswerMutex.RUnlock()
	fake.handleOfferMutex.RLock()
	defer fake.handleOfferMutex.RUnlock()
	fake.hiddenMutex.RLock()
	defer fake.hiddenMutex.RUnlock()
	fake.iCERestartMutex.RLock()
	defer fake.iCERestartMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.identityMutex.RLock()
	defer fake.identityMutex.RUnlock()
	fake.isPublisherMutex.RLock()
	defer fake.isPublisherMutex.RUnlock()
	fake.isReadyMutex.RLock()
	defer fake.isReadyMutex.RUnlock()
	fake.isRecorderMutex.RLock()
	defer fake.isRecorderMutex.RUnlock()
	fake.isSubscribedToMutex.RLock()
	defer fake.isSubscribedToMutex.RUnlock()
	fake.maybeStartMigrationMutex.RLock()
	defer fake.maybeStartMigrationMutex.RUnlock()
	fake.migrateStateMutex.RLock()
	defer fake.migrateStateMutex.RUnlock()
	fake.negotiateMutex.RLock()
	defer fake.negotiateMutex.RUnlock()
	fake.onClaimsChangedMutex.RLock()
	defer fake.onClaimsChangedMutex.RUnlock()
	fake.onCloseMutex.RLock()
	defer fake.onCloseMutex.RUnlock()
	fake.onDataPacketMutex.RLock()
	defer fake.onDataPacketMutex.RUnlock()
	fake.onICEConfigChangedMutex.RLock()
	defer fake.onICEConfigChangedMutex.RUnlock()
	fake.onParticipantUpdateMutex.RLock()
	defer fake.onParticipantUpdateMutex.RUnlock()
	fake.onReceiverReportMutex.RLock()
	defer fake.onReceiverReportMutex.RUnlock()
	fake.onStateChangeMutex.RLock()
	defer fake.onStateChangeMutex.RUnlock()
	fake.onSubscribedToMutex.RLock()
	defer fake.onSubscribedToMutex.RUnlock()
	fake.onTrackPublishedMutex.RLock()
	defer fake.onTrackPublishedMutex.RUnlock()
	fake.onTrackUpdatedMutex.RLock()
	defer fake.onTrackUpdatedMutex.RUnlock()
	fake.processSubscriptionRequestsQueueMutex.RLock()
	defer fake.processSubscriptionRequestsQueueMutex.RUnlock()
	fake.protocolVersionMutex.RLock()
	defer fake.protocolVersionMutex.RUnlock()
	fake.removePublishedTrackMutex.RLock()
	defer fake.removePublishedTrackMutex.RUnlock()
	fake.removeSubscribedTrackMutex.RLock()
	defer fake.removeSubscribedTrackMutex.RUnlock()
	fake.removeSubscriberMutex.RLock()
	defer fake.removeSubscriberMutex.RUnlock()
	fake.removeTrackFromSubscriberMutex.RLock()
	defer fake.removeTrackFromSubscriberMutex.RUnlock()
	fake.sendConnectionQualityUpdateMutex.RLock()
	defer fake.sendConnectionQualityUpdateMutex.RUnlock()
	fake.sendDataPacketMutex.RLock()
	defer fake.sendDataPacketMutex.RUnlock()
	fake.sendJoinResponseMutex.RLock()
	defer fake.sendJoinResponseMutex.RUnlock()
	fake.sendParticipantUpdateMutex.RLock()
	defer fake.sendParticipantUpdateMutex.RUnlock()
	fake.sendRefreshTokenMutex.RLock()
	defer fake.sendRefreshTokenMutex.RUnlock()
	fake.sendRoomUpdateMutex.RLock()
	defer fake.sendRoomUpdateMutex.RUnlock()
	fake.sendSpeakerUpdateMutex.RLock()
	defer fake.sendSpeakerUpdateMutex.RUnlock()
	fake.setICEConfigMutex.RLock()
	defer fake.setICEConfigMutex.RUnlock()
	fake.setMetadataMutex.RLock()
	defer fake.setMetadataMutex.RUnlock()
	fake.setMigrateInfoMutex.RLock()
	defer fake.setMigrateInfoMutex.RUnlock()
	fake.setMigrateStateMutex.RLock()
	defer fake.setMigrateStateMutex.RUnlock()
	fake.setPermissionMutex.RLock()
	defer fake.setPermissionMutex.RUnlock()
	fake.setResponseSinkMutex.RLock()
	defer fake.setResponseSinkMutex.RUnlock()
	fake.setTrackMutedMutex.RLock()
	defer fake.setTrackMutedMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	fake.subscriberAsPrimaryMutex.RLock()
	defer fake.subscriberAsPrimaryMutex.RUnlock()
	fake.subscriptionPermissionMutex.RLock()
	defer fake.subscriptionPermissionMutex.RUnlock()
	fake.subscriptionPermissionUpdateMutex.RLock()
	defer fake.subscriptionPermissionUpdateMutex.RUnlock()
	fake.toProtoMutex.RLock()
	defer fake.toProtoMutex.RUnlock()
	fake.uncacheDownTrackMutex.RLock()
	defer fake.uncacheDownTrackMutex.RUnlock()
	fake.updateMediaLossMutex.RLock()
	defer fake.updateMediaLossMutex.RUnlock()
	fake.updateRTTMutex.RLock()
	defer fake.updateRTTMutex.RUnlock()
	fake.updateSubscribedQualityMutex.RLock()
	defer fake.updateSubscribedQualityMutex.RUnlock()
	fake.updateSubscribedTrackSettingsMutex.RLock()
	defer fake.updateSubscribedTrackSettingsMutex.RUnlock()
	fake.updateSubscriptionPermissionMutex.RLock()
	defer fake.updateSubscriptionPermissionMutex.RUnlock()
	fake.updateVideoLayersMutex.RLock()
	defer fake.updateVideoLayersMutex.RUnlock()
	fake.verifySubscribeParticipantInfoMutex.RLock()
	defer fake.verifySubscribeParticipantInfoMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeLocalParticipant) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ types.LocalParticipant = new(FakeLocalParticipant)
