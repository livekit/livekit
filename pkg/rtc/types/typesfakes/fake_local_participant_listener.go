// Code generated by counterfeiter. DO NOT EDIT.
package typesfakes

import (
	"sync"

	"github.com/livekit/livekit-server/pkg/rtc/datatrack"
	"github.com/livekit/livekit-server/pkg/rtc/types"
	"github.com/livekit/protocol/livekit"
)

type FakeLocalParticipantListener struct {
	OnDataMessageStub        func(types.LocalParticipant, livekit.DataPacket_Kind, *livekit.DataPacket)
	onDataMessageMutex       sync.RWMutex
	onDataMessageArgsForCall []struct {
		arg1 types.LocalParticipant
		arg2 livekit.DataPacket_Kind
		arg3 *livekit.DataPacket
	}
	OnDataMessageUnlabeledStub        func(types.LocalParticipant, []byte)
	onDataMessageUnlabeledMutex       sync.RWMutex
	onDataMessageUnlabeledArgsForCall []struct {
		arg1 types.LocalParticipant
		arg2 []byte
	}
	OnDataTrackMessageStub        func(types.Participant, []byte, *datatrack.Packet)
	onDataTrackMessageMutex       sync.RWMutex
	onDataTrackMessageArgsForCall []struct {
		arg1 types.Participant
		arg2 []byte
		arg3 *datatrack.Packet
	}
	OnDataTrackPublishedStub        func(types.Participant, types.DataTrack)
	onDataTrackPublishedMutex       sync.RWMutex
	onDataTrackPublishedArgsForCall []struct {
		arg1 types.Participant
		arg2 types.DataTrack
	}
	OnDataTrackUnpublishedStub        func(types.Participant, types.DataTrack)
	onDataTrackUnpublishedMutex       sync.RWMutex
	onDataTrackUnpublishedArgsForCall []struct {
		arg1 types.Participant
		arg2 types.DataTrack
	}
	OnLeaveStub        func(types.LocalParticipant, types.ParticipantCloseReason)
	onLeaveMutex       sync.RWMutex
	onLeaveArgsForCall []struct {
		arg1 types.LocalParticipant
		arg2 types.ParticipantCloseReason
	}
	OnMetricsStub        func(types.Participant, *livekit.DataPacket)
	onMetricsMutex       sync.RWMutex
	onMetricsArgsForCall []struct {
		arg1 types.Participant
		arg2 *livekit.DataPacket
	}
	OnMigrateStateChangeStub        func(types.LocalParticipant, types.MigrateState)
	onMigrateStateChangeMutex       sync.RWMutex
	onMigrateStateChangeArgsForCall []struct {
		arg1 types.LocalParticipant
		arg2 types.MigrateState
	}
	OnParticipantUpdateStub        func(types.Participant)
	onParticipantUpdateMutex       sync.RWMutex
	onParticipantUpdateArgsForCall []struct {
		arg1 types.Participant
	}
	OnSimulateScenarioStub        func(types.LocalParticipant, *livekit.SimulateScenario) error
	onSimulateScenarioMutex       sync.RWMutex
	onSimulateScenarioArgsForCall []struct {
		arg1 types.LocalParticipant
		arg2 *livekit.SimulateScenario
	}
	onSimulateScenarioReturns struct {
		result1 error
	}
	onSimulateScenarioReturnsOnCall map[int]struct {
		result1 error
	}
	OnStateChangeStub        func(types.LocalParticipant)
	onStateChangeMutex       sync.RWMutex
	onStateChangeArgsForCall []struct {
		arg1 types.LocalParticipant
	}
	OnSubscribeStatusChangedStub        func(types.LocalParticipant, livekit.ParticipantID, bool)
	onSubscribeStatusChangedMutex       sync.RWMutex
	onSubscribeStatusChangedArgsForCall []struct {
		arg1 types.LocalParticipant
		arg2 livekit.ParticipantID
		arg3 bool
	}
	OnSubscriberReadyStub        func(types.LocalParticipant)
	onSubscriberReadyMutex       sync.RWMutex
	onSubscriberReadyArgsForCall []struct {
		arg1 types.LocalParticipant
	}
	OnSyncStateStub        func(types.LocalParticipant, *livekit.SyncState) error
	onSyncStateMutex       sync.RWMutex
	onSyncStateArgsForCall []struct {
		arg1 types.LocalParticipant
		arg2 *livekit.SyncState
	}
	onSyncStateReturns struct {
		result1 error
	}
	onSyncStateReturnsOnCall map[int]struct {
		result1 error
	}
	OnTrackPublishedStub        func(types.Participant, types.MediaTrack)
	onTrackPublishedMutex       sync.RWMutex
	onTrackPublishedArgsForCall []struct {
		arg1 types.Participant
		arg2 types.MediaTrack
	}
	OnTrackUnpublishedStub        func(types.Participant, types.MediaTrack)
	onTrackUnpublishedMutex       sync.RWMutex
	onTrackUnpublishedArgsForCall []struct {
		arg1 types.Participant
		arg2 types.MediaTrack
	}
	OnTrackUpdatedStub        func(types.Participant, types.MediaTrack)
	onTrackUpdatedMutex       sync.RWMutex
	onTrackUpdatedArgsForCall []struct {
		arg1 types.Participant
		arg2 types.MediaTrack
	}
	OnUpdateDataSubscriptionsStub        func(types.LocalParticipant, *livekit.UpdateDataSubscription)
	onUpdateDataSubscriptionsMutex       sync.RWMutex
	onUpdateDataSubscriptionsArgsForCall []struct {
		arg1 types.LocalParticipant
		arg2 *livekit.UpdateDataSubscription
	}
	OnUpdateSubscriptionPermissionStub        func(types.LocalParticipant, *livekit.SubscriptionPermission) error
	onUpdateSubscriptionPermissionMutex       sync.RWMutex
	onUpdateSubscriptionPermissionArgsForCall []struct {
		arg1 types.LocalParticipant
		arg2 *livekit.SubscriptionPermission
	}
	onUpdateSubscriptionPermissionReturns struct {
		result1 error
	}
	onUpdateSubscriptionPermissionReturnsOnCall map[int]struct {
		result1 error
	}
	OnUpdateSubscriptionsStub        func(types.LocalParticipant, []livekit.TrackID, []*livekit.ParticipantTracks, bool)
	onUpdateSubscriptionsMutex       sync.RWMutex
	onUpdateSubscriptionsArgsForCall []struct {
		arg1 types.LocalParticipant
		arg2 []livekit.TrackID
		arg3 []*livekit.ParticipantTracks
		arg4 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeLocalParticipantListener) OnDataMessage(arg1 types.LocalParticipant, arg2 livekit.DataPacket_Kind, arg3 *livekit.DataPacket) {
	fake.onDataMessageMutex.Lock()
	fake.onDataMessageArgsForCall = append(fake.onDataMessageArgsForCall, struct {
		arg1 types.LocalParticipant
		arg2 livekit.DataPacket_Kind
		arg3 *livekit.DataPacket
	}{arg1, arg2, arg3})
	stub := fake.OnDataMessageStub
	fake.recordInvocation("OnDataMessage", []interface{}{arg1, arg2, arg3})
	fake.onDataMessageMutex.Unlock()
	if stub != nil {
		fake.OnDataMessageStub(arg1, arg2, arg3)
	}
}

func (fake *FakeLocalParticipantListener) OnDataMessageCallCount() int {
	fake.onDataMessageMutex.RLock()
	defer fake.onDataMessageMutex.RUnlock()
	return len(fake.onDataMessageArgsForCall)
}

func (fake *FakeLocalParticipantListener) OnDataMessageCalls(stub func(types.LocalParticipant, livekit.DataPacket_Kind, *livekit.DataPacket)) {
	fake.onDataMessageMutex.Lock()
	defer fake.onDataMessageMutex.Unlock()
	fake.OnDataMessageStub = stub
}

func (fake *FakeLocalParticipantListener) OnDataMessageArgsForCall(i int) (types.LocalParticipant, livekit.DataPacket_Kind, *livekit.DataPacket) {
	fake.onDataMessageMutex.RLock()
	defer fake.onDataMessageMutex.RUnlock()
	argsForCall := fake.onDataMessageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLocalParticipantListener) OnDataMessageUnlabeled(arg1 types.LocalParticipant, arg2 []byte) {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.onDataMessageUnlabeledMutex.Lock()
	fake.onDataMessageUnlabeledArgsForCall = append(fake.onDataMessageUnlabeledArgsForCall, struct {
		arg1 types.LocalParticipant
		arg2 []byte
	}{arg1, arg2Copy})
	stub := fake.OnDataMessageUnlabeledStub
	fake.recordInvocation("OnDataMessageUnlabeled", []interface{}{arg1, arg2Copy})
	fake.onDataMessageUnlabeledMutex.Unlock()
	if stub != nil {
		fake.OnDataMessageUnlabeledStub(arg1, arg2)
	}
}

func (fake *FakeLocalParticipantListener) OnDataMessageUnlabeledCallCount() int {
	fake.onDataMessageUnlabeledMutex.RLock()
	defer fake.onDataMessageUnlabeledMutex.RUnlock()
	return len(fake.onDataMessageUnlabeledArgsForCall)
}

func (fake *FakeLocalParticipantListener) OnDataMessageUnlabeledCalls(stub func(types.LocalParticipant, []byte)) {
	fake.onDataMessageUnlabeledMutex.Lock()
	defer fake.onDataMessageUnlabeledMutex.Unlock()
	fake.OnDataMessageUnlabeledStub = stub
}

func (fake *FakeLocalParticipantListener) OnDataMessageUnlabeledArgsForCall(i int) (types.LocalParticipant, []byte) {
	fake.onDataMessageUnlabeledMutex.RLock()
	defer fake.onDataMessageUnlabeledMutex.RUnlock()
	argsForCall := fake.onDataMessageUnlabeledArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipantListener) OnDataTrackMessage(arg1 types.Participant, arg2 []byte, arg3 *datatrack.Packet) {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.onDataTrackMessageMutex.Lock()
	fake.onDataTrackMessageArgsForCall = append(fake.onDataTrackMessageArgsForCall, struct {
		arg1 types.Participant
		arg2 []byte
		arg3 *datatrack.Packet
	}{arg1, arg2Copy, arg3})
	stub := fake.OnDataTrackMessageStub
	fake.recordInvocation("OnDataTrackMessage", []interface{}{arg1, arg2Copy, arg3})
	fake.onDataTrackMessageMutex.Unlock()
	if stub != nil {
		fake.OnDataTrackMessageStub(arg1, arg2, arg3)
	}
}

func (fake *FakeLocalParticipantListener) OnDataTrackMessageCallCount() int {
	fake.onDataTrackMessageMutex.RLock()
	defer fake.onDataTrackMessageMutex.RUnlock()
	return len(fake.onDataTrackMessageArgsForCall)
}

func (fake *FakeLocalParticipantListener) OnDataTrackMessageCalls(stub func(types.Participant, []byte, *datatrack.Packet)) {
	fake.onDataTrackMessageMutex.Lock()
	defer fake.onDataTrackMessageMutex.Unlock()
	fake.OnDataTrackMessageStub = stub
}

func (fake *FakeLocalParticipantListener) OnDataTrackMessageArgsForCall(i int) (types.Participant, []byte, *datatrack.Packet) {
	fake.onDataTrackMessageMutex.RLock()
	defer fake.onDataTrackMessageMutex.RUnlock()
	argsForCall := fake.onDataTrackMessageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLocalParticipantListener) OnDataTrackPublished(arg1 types.Participant, arg2 types.DataTrack) {
	fake.onDataTrackPublishedMutex.Lock()
	fake.onDataTrackPublishedArgsForCall = append(fake.onDataTrackPublishedArgsForCall, struct {
		arg1 types.Participant
		arg2 types.DataTrack
	}{arg1, arg2})
	stub := fake.OnDataTrackPublishedStub
	fake.recordInvocation("OnDataTrackPublished", []interface{}{arg1, arg2})
	fake.onDataTrackPublishedMutex.Unlock()
	if stub != nil {
		fake.OnDataTrackPublishedStub(arg1, arg2)
	}
}

func (fake *FakeLocalParticipantListener) OnDataTrackPublishedCallCount() int {
	fake.onDataTrackPublishedMutex.RLock()
	defer fake.onDataTrackPublishedMutex.RUnlock()
	return len(fake.onDataTrackPublishedArgsForCall)
}

func (fake *FakeLocalParticipantListener) OnDataTrackPublishedCalls(stub func(types.Participant, types.DataTrack)) {
	fake.onDataTrackPublishedMutex.Lock()
	defer fake.onDataTrackPublishedMutex.Unlock()
	fake.OnDataTrackPublishedStub = stub
}

func (fake *FakeLocalParticipantListener) OnDataTrackPublishedArgsForCall(i int) (types.Participant, types.DataTrack) {
	fake.onDataTrackPublishedMutex.RLock()
	defer fake.onDataTrackPublishedMutex.RUnlock()
	argsForCall := fake.onDataTrackPublishedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipantListener) OnDataTrackUnpublished(arg1 types.Participant, arg2 types.DataTrack) {
	fake.onDataTrackUnpublishedMutex.Lock()
	fake.onDataTrackUnpublishedArgsForCall = append(fake.onDataTrackUnpublishedArgsForCall, struct {
		arg1 types.Participant
		arg2 types.DataTrack
	}{arg1, arg2})
	stub := fake.OnDataTrackUnpublishedStub
	fake.recordInvocation("OnDataTrackUnpublished", []interface{}{arg1, arg2})
	fake.onDataTrackUnpublishedMutex.Unlock()
	if stub != nil {
		fake.OnDataTrackUnpublishedStub(arg1, arg2)
	}
}

func (fake *FakeLocalParticipantListener) OnDataTrackUnpublishedCallCount() int {
	fake.onDataTrackUnpublishedMutex.RLock()
	defer fake.onDataTrackUnpublishedMutex.RUnlock()
	return len(fake.onDataTrackUnpublishedArgsForCall)
}

func (fake *FakeLocalParticipantListener) OnDataTrackUnpublishedCalls(stub func(types.Participant, types.DataTrack)) {
	fake.onDataTrackUnpublishedMutex.Lock()
	defer fake.onDataTrackUnpublishedMutex.Unlock()
	fake.OnDataTrackUnpublishedStub = stub
}

func (fake *FakeLocalParticipantListener) OnDataTrackUnpublishedArgsForCall(i int) (types.Participant, types.DataTrack) {
	fake.onDataTrackUnpublishedMutex.RLock()
	defer fake.onDataTrackUnpublishedMutex.RUnlock()
	argsForCall := fake.onDataTrackUnpublishedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipantListener) OnLeave(arg1 types.LocalParticipant, arg2 types.ParticipantCloseReason) {
	fake.onLeaveMutex.Lock()
	fake.onLeaveArgsForCall = append(fake.onLeaveArgsForCall, struct {
		arg1 types.LocalParticipant
		arg2 types.ParticipantCloseReason
	}{arg1, arg2})
	stub := fake.OnLeaveStub
	fake.recordInvocation("OnLeave", []interface{}{arg1, arg2})
	fake.onLeaveMutex.Unlock()
	if stub != nil {
		fake.OnLeaveStub(arg1, arg2)
	}
}

func (fake *FakeLocalParticipantListener) OnLeaveCallCount() int {
	fake.onLeaveMutex.RLock()
	defer fake.onLeaveMutex.RUnlock()
	return len(fake.onLeaveArgsForCall)
}

func (fake *FakeLocalParticipantListener) OnLeaveCalls(stub func(types.LocalParticipant, types.ParticipantCloseReason)) {
	fake.onLeaveMutex.Lock()
	defer fake.onLeaveMutex.Unlock()
	fake.OnLeaveStub = stub
}

func (fake *FakeLocalParticipantListener) OnLeaveArgsForCall(i int) (types.LocalParticipant, types.ParticipantCloseReason) {
	fake.onLeaveMutex.RLock()
	defer fake.onLeaveMutex.RUnlock()
	argsForCall := fake.onLeaveArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipantListener) OnMetrics(arg1 types.Participant, arg2 *livekit.DataPacket) {
	fake.onMetricsMutex.Lock()
	fake.onMetricsArgsForCall = append(fake.onMetricsArgsForCall, struct {
		arg1 types.Participant
		arg2 *livekit.DataPacket
	}{arg1, arg2})
	stub := fake.OnMetricsStub
	fake.recordInvocation("OnMetrics", []interface{}{arg1, arg2})
	fake.onMetricsMutex.Unlock()
	if stub != nil {
		fake.OnMetricsStub(arg1, arg2)
	}
}

func (fake *FakeLocalParticipantListener) OnMetricsCallCount() int {
	fake.onMetricsMutex.RLock()
	defer fake.onMetricsMutex.RUnlock()
	return len(fake.onMetricsArgsForCall)
}

func (fake *FakeLocalParticipantListener) OnMetricsCalls(stub func(types.Participant, *livekit.DataPacket)) {
	fake.onMetricsMutex.Lock()
	defer fake.onMetricsMutex.Unlock()
	fake.OnMetricsStub = stub
}

func (fake *FakeLocalParticipantListener) OnMetricsArgsForCall(i int) (types.Participant, *livekit.DataPacket) {
	fake.onMetricsMutex.RLock()
	defer fake.onMetricsMutex.RUnlock()
	argsForCall := fake.onMetricsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipantListener) OnMigrateStateChange(arg1 types.LocalParticipant, arg2 types.MigrateState) {
	fake.onMigrateStateChangeMutex.Lock()
	fake.onMigrateStateChangeArgsForCall = append(fake.onMigrateStateChangeArgsForCall, struct {
		arg1 types.LocalParticipant
		arg2 types.MigrateState
	}{arg1, arg2})
	stub := fake.OnMigrateStateChangeStub
	fake.recordInvocation("OnMigrateStateChange", []interface{}{arg1, arg2})
	fake.onMigrateStateChangeMutex.Unlock()
	if stub != nil {
		fake.OnMigrateStateChangeStub(arg1, arg2)
	}
}

func (fake *FakeLocalParticipantListener) OnMigrateStateChangeCallCount() int {
	fake.onMigrateStateChangeMutex.RLock()
	defer fake.onMigrateStateChangeMutex.RUnlock()
	return len(fake.onMigrateStateChangeArgsForCall)
}

func (fake *FakeLocalParticipantListener) OnMigrateStateChangeCalls(stub func(types.LocalParticipant, types.MigrateState)) {
	fake.onMigrateStateChangeMutex.Lock()
	defer fake.onMigrateStateChangeMutex.Unlock()
	fake.OnMigrateStateChangeStub = stub
}

func (fake *FakeLocalParticipantListener) OnMigrateStateChangeArgsForCall(i int) (types.LocalParticipant, types.MigrateState) {
	fake.onMigrateStateChangeMutex.RLock()
	defer fake.onMigrateStateChangeMutex.RUnlock()
	argsForCall := fake.onMigrateStateChangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipantListener) OnParticipantUpdate(arg1 types.Participant) {
	fake.onParticipantUpdateMutex.Lock()
	fake.onParticipantUpdateArgsForCall = append(fake.onParticipantUpdateArgsForCall, struct {
		arg1 types.Participant
	}{arg1})
	stub := fake.OnParticipantUpdateStub
	fake.recordInvocation("OnParticipantUpdate", []interface{}{arg1})
	fake.onParticipantUpdateMutex.Unlock()
	if stub != nil {
		fake.OnParticipantUpdateStub(arg1)
	}
}

func (fake *FakeLocalParticipantListener) OnParticipantUpdateCallCount() int {
	fake.onParticipantUpdateMutex.RLock()
	defer fake.onParticipantUpdateMutex.RUnlock()
	return len(fake.onParticipantUpdateArgsForCall)
}

func (fake *FakeLocalParticipantListener) OnParticipantUpdateCalls(stub func(types.Participant)) {
	fake.onParticipantUpdateMutex.Lock()
	defer fake.onParticipantUpdateMutex.Unlock()
	fake.OnParticipantUpdateStub = stub
}

func (fake *FakeLocalParticipantListener) OnParticipantUpdateArgsForCall(i int) types.Participant {
	fake.onParticipantUpdateMutex.RLock()
	defer fake.onParticipantUpdateMutex.RUnlock()
	argsForCall := fake.onParticipantUpdateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipantListener) OnSimulateScenario(arg1 types.LocalParticipant, arg2 *livekit.SimulateScenario) error {
	fake.onSimulateScenarioMutex.Lock()
	ret, specificReturn := fake.onSimulateScenarioReturnsOnCall[len(fake.onSimulateScenarioArgsForCall)]
	fake.onSimulateScenarioArgsForCall = append(fake.onSimulateScenarioArgsForCall, struct {
		arg1 types.LocalParticipant
		arg2 *livekit.SimulateScenario
	}{arg1, arg2})
	stub := fake.OnSimulateScenarioStub
	fakeReturns := fake.onSimulateScenarioReturns
	fake.recordInvocation("OnSimulateScenario", []interface{}{arg1, arg2})
	fake.onSimulateScenarioMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipantListener) OnSimulateScenarioCallCount() int {
	fake.onSimulateScenarioMutex.RLock()
	defer fake.onSimulateScenarioMutex.RUnlock()
	return len(fake.onSimulateScenarioArgsForCall)
}

func (fake *FakeLocalParticipantListener) OnSimulateScenarioCalls(stub func(types.LocalParticipant, *livekit.SimulateScenario) error) {
	fake.onSimulateScenarioMutex.Lock()
	defer fake.onSimulateScenarioMutex.Unlock()
	fake.OnSimulateScenarioStub = stub
}

func (fake *FakeLocalParticipantListener) OnSimulateScenarioArgsForCall(i int) (types.LocalParticipant, *livekit.SimulateScenario) {
	fake.onSimulateScenarioMutex.RLock()
	defer fake.onSimulateScenarioMutex.RUnlock()
	argsForCall := fake.onSimulateScenarioArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipantListener) OnSimulateScenarioReturns(result1 error) {
	fake.onSimulateScenarioMutex.Lock()
	defer fake.onSimulateScenarioMutex.Unlock()
	fake.OnSimulateScenarioStub = nil
	fake.onSimulateScenarioReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipantListener) OnSimulateScenarioReturnsOnCall(i int, result1 error) {
	fake.onSimulateScenarioMutex.Lock()
	defer fake.onSimulateScenarioMutex.Unlock()
	fake.OnSimulateScenarioStub = nil
	if fake.onSimulateScenarioReturnsOnCall == nil {
		fake.onSimulateScenarioReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.onSimulateScenarioReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipantListener) OnStateChange(arg1 types.LocalParticipant) {
	fake.onStateChangeMutex.Lock()
	fake.onStateChangeArgsForCall = append(fake.onStateChangeArgsForCall, struct {
		arg1 types.LocalParticipant
	}{arg1})
	stub := fake.OnStateChangeStub
	fake.recordInvocation("OnStateChange", []interface{}{arg1})
	fake.onStateChangeMutex.Unlock()
	if stub != nil {
		fake.OnStateChangeStub(arg1)
	}
}

func (fake *FakeLocalParticipantListener) OnStateChangeCallCount() int {
	fake.onStateChangeMutex.RLock()
	defer fake.onStateChangeMutex.RUnlock()
	return len(fake.onStateChangeArgsForCall)
}

func (fake *FakeLocalParticipantListener) OnStateChangeCalls(stub func(types.LocalParticipant)) {
	fake.onStateChangeMutex.Lock()
	defer fake.onStateChangeMutex.Unlock()
	fake.OnStateChangeStub = stub
}

func (fake *FakeLocalParticipantListener) OnStateChangeArgsForCall(i int) types.LocalParticipant {
	fake.onStateChangeMutex.RLock()
	defer fake.onStateChangeMutex.RUnlock()
	argsForCall := fake.onStateChangeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipantListener) OnSubscribeStatusChanged(arg1 types.LocalParticipant, arg2 livekit.ParticipantID, arg3 bool) {
	fake.onSubscribeStatusChangedMutex.Lock()
	fake.onSubscribeStatusChangedArgsForCall = append(fake.onSubscribeStatusChangedArgsForCall, struct {
		arg1 types.LocalParticipant
		arg2 livekit.ParticipantID
		arg3 bool
	}{arg1, arg2, arg3})
	stub := fake.OnSubscribeStatusChangedStub
	fake.recordInvocation("OnSubscribeStatusChanged", []interface{}{arg1, arg2, arg3})
	fake.onSubscribeStatusChangedMutex.Unlock()
	if stub != nil {
		fake.OnSubscribeStatusChangedStub(arg1, arg2, arg3)
	}
}

func (fake *FakeLocalParticipantListener) OnSubscribeStatusChangedCallCount() int {
	fake.onSubscribeStatusChangedMutex.RLock()
	defer fake.onSubscribeStatusChangedMutex.RUnlock()
	return len(fake.onSubscribeStatusChangedArgsForCall)
}

func (fake *FakeLocalParticipantListener) OnSubscribeStatusChangedCalls(stub func(types.LocalParticipant, livekit.ParticipantID, bool)) {
	fake.onSubscribeStatusChangedMutex.Lock()
	defer fake.onSubscribeStatusChangedMutex.Unlock()
	fake.OnSubscribeStatusChangedStub = stub
}

func (fake *FakeLocalParticipantListener) OnSubscribeStatusChangedArgsForCall(i int) (types.LocalParticipant, livekit.ParticipantID, bool) {
	fake.onSubscribeStatusChangedMutex.RLock()
	defer fake.onSubscribeStatusChangedMutex.RUnlock()
	argsForCall := fake.onSubscribeStatusChangedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeLocalParticipantListener) OnSubscriberReady(arg1 types.LocalParticipant) {
	fake.onSubscriberReadyMutex.Lock()
	fake.onSubscriberReadyArgsForCall = append(fake.onSubscriberReadyArgsForCall, struct {
		arg1 types.LocalParticipant
	}{arg1})
	stub := fake.OnSubscriberReadyStub
	fake.recordInvocation("OnSubscriberReady", []interface{}{arg1})
	fake.onSubscriberReadyMutex.Unlock()
	if stub != nil {
		fake.OnSubscriberReadyStub(arg1)
	}
}

func (fake *FakeLocalParticipantListener) OnSubscriberReadyCallCount() int {
	fake.onSubscriberReadyMutex.RLock()
	defer fake.onSubscriberReadyMutex.RUnlock()
	return len(fake.onSubscriberReadyArgsForCall)
}

func (fake *FakeLocalParticipantListener) OnSubscriberReadyCalls(stub func(types.LocalParticipant)) {
	fake.onSubscriberReadyMutex.Lock()
	defer fake.onSubscriberReadyMutex.Unlock()
	fake.OnSubscriberReadyStub = stub
}

func (fake *FakeLocalParticipantListener) OnSubscriberReadyArgsForCall(i int) types.LocalParticipant {
	fake.onSubscriberReadyMutex.RLock()
	defer fake.onSubscriberReadyMutex.RUnlock()
	argsForCall := fake.onSubscriberReadyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLocalParticipantListener) OnSyncState(arg1 types.LocalParticipant, arg2 *livekit.SyncState) error {
	fake.onSyncStateMutex.Lock()
	ret, specificReturn := fake.onSyncStateReturnsOnCall[len(fake.onSyncStateArgsForCall)]
	fake.onSyncStateArgsForCall = append(fake.onSyncStateArgsForCall, struct {
		arg1 types.LocalParticipant
		arg2 *livekit.SyncState
	}{arg1, arg2})
	stub := fake.OnSyncStateStub
	fakeReturns := fake.onSyncStateReturns
	fake.recordInvocation("OnSyncState", []interface{}{arg1, arg2})
	fake.onSyncStateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipantListener) OnSyncStateCallCount() int {
	fake.onSyncStateMutex.RLock()
	defer fake.onSyncStateMutex.RUnlock()
	return len(fake.onSyncStateArgsForCall)
}

func (fake *FakeLocalParticipantListener) OnSyncStateCalls(stub func(types.LocalParticipant, *livekit.SyncState) error) {
	fake.onSyncStateMutex.Lock()
	defer fake.onSyncStateMutex.Unlock()
	fake.OnSyncStateStub = stub
}

func (fake *FakeLocalParticipantListener) OnSyncStateArgsForCall(i int) (types.LocalParticipant, *livekit.SyncState) {
	fake.onSyncStateMutex.RLock()
	defer fake.onSyncStateMutex.RUnlock()
	argsForCall := fake.onSyncStateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipantListener) OnSyncStateReturns(result1 error) {
	fake.onSyncStateMutex.Lock()
	defer fake.onSyncStateMutex.Unlock()
	fake.OnSyncStateStub = nil
	fake.onSyncStateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipantListener) OnSyncStateReturnsOnCall(i int, result1 error) {
	fake.onSyncStateMutex.Lock()
	defer fake.onSyncStateMutex.Unlock()
	fake.OnSyncStateStub = nil
	if fake.onSyncStateReturnsOnCall == nil {
		fake.onSyncStateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.onSyncStateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipantListener) OnTrackPublished(arg1 types.Participant, arg2 types.MediaTrack) {
	fake.onTrackPublishedMutex.Lock()
	fake.onTrackPublishedArgsForCall = append(fake.onTrackPublishedArgsForCall, struct {
		arg1 types.Participant
		arg2 types.MediaTrack
	}{arg1, arg2})
	stub := fake.OnTrackPublishedStub
	fake.recordInvocation("OnTrackPublished", []interface{}{arg1, arg2})
	fake.onTrackPublishedMutex.Unlock()
	if stub != nil {
		fake.OnTrackPublishedStub(arg1, arg2)
	}
}

func (fake *FakeLocalParticipantListener) OnTrackPublishedCallCount() int {
	fake.onTrackPublishedMutex.RLock()
	defer fake.onTrackPublishedMutex.RUnlock()
	return len(fake.onTrackPublishedArgsForCall)
}

func (fake *FakeLocalParticipantListener) OnTrackPublishedCalls(stub func(types.Participant, types.MediaTrack)) {
	fake.onTrackPublishedMutex.Lock()
	defer fake.onTrackPublishedMutex.Unlock()
	fake.OnTrackPublishedStub = stub
}

func (fake *FakeLocalParticipantListener) OnTrackPublishedArgsForCall(i int) (types.Participant, types.MediaTrack) {
	fake.onTrackPublishedMutex.RLock()
	defer fake.onTrackPublishedMutex.RUnlock()
	argsForCall := fake.onTrackPublishedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipantListener) OnTrackUnpublished(arg1 types.Participant, arg2 types.MediaTrack) {
	fake.onTrackUnpublishedMutex.Lock()
	fake.onTrackUnpublishedArgsForCall = append(fake.onTrackUnpublishedArgsForCall, struct {
		arg1 types.Participant
		arg2 types.MediaTrack
	}{arg1, arg2})
	stub := fake.OnTrackUnpublishedStub
	fake.recordInvocation("OnTrackUnpublished", []interface{}{arg1, arg2})
	fake.onTrackUnpublishedMutex.Unlock()
	if stub != nil {
		fake.OnTrackUnpublishedStub(arg1, arg2)
	}
}

func (fake *FakeLocalParticipantListener) OnTrackUnpublishedCallCount() int {
	fake.onTrackUnpublishedMutex.RLock()
	defer fake.onTrackUnpublishedMutex.RUnlock()
	return len(fake.onTrackUnpublishedArgsForCall)
}

func (fake *FakeLocalParticipantListener) OnTrackUnpublishedCalls(stub func(types.Participant, types.MediaTrack)) {
	fake.onTrackUnpublishedMutex.Lock()
	defer fake.onTrackUnpublishedMutex.Unlock()
	fake.OnTrackUnpublishedStub = stub
}

func (fake *FakeLocalParticipantListener) OnTrackUnpublishedArgsForCall(i int) (types.Participant, types.MediaTrack) {
	fake.onTrackUnpublishedMutex.RLock()
	defer fake.onTrackUnpublishedMutex.RUnlock()
	argsForCall := fake.onTrackUnpublishedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipantListener) OnTrackUpdated(arg1 types.Participant, arg2 types.MediaTrack) {
	fake.onTrackUpdatedMutex.Lock()
	fake.onTrackUpdatedArgsForCall = append(fake.onTrackUpdatedArgsForCall, struct {
		arg1 types.Participant
		arg2 types.MediaTrack
	}{arg1, arg2})
	stub := fake.OnTrackUpdatedStub
	fake.recordInvocation("OnTrackUpdated", []interface{}{arg1, arg2})
	fake.onTrackUpdatedMutex.Unlock()
	if stub != nil {
		fake.OnTrackUpdatedStub(arg1, arg2)
	}
}

func (fake *FakeLocalParticipantListener) OnTrackUpdatedCallCount() int {
	fake.onTrackUpdatedMutex.RLock()
	defer fake.onTrackUpdatedMutex.RUnlock()
	return len(fake.onTrackUpdatedArgsForCall)
}

func (fake *FakeLocalParticipantListener) OnTrackUpdatedCalls(stub func(types.Participant, types.MediaTrack)) {
	fake.onTrackUpdatedMutex.Lock()
	defer fake.onTrackUpdatedMutex.Unlock()
	fake.OnTrackUpdatedStub = stub
}

func (fake *FakeLocalParticipantListener) OnTrackUpdatedArgsForCall(i int) (types.Participant, types.MediaTrack) {
	fake.onTrackUpdatedMutex.RLock()
	defer fake.onTrackUpdatedMutex.RUnlock()
	argsForCall := fake.onTrackUpdatedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipantListener) OnUpdateDataSubscriptions(arg1 types.LocalParticipant, arg2 *livekit.UpdateDataSubscription) {
	fake.onUpdateDataSubscriptionsMutex.Lock()
	fake.onUpdateDataSubscriptionsArgsForCall = append(fake.onUpdateDataSubscriptionsArgsForCall, struct {
		arg1 types.LocalParticipant
		arg2 *livekit.UpdateDataSubscription
	}{arg1, arg2})
	stub := fake.OnUpdateDataSubscriptionsStub
	fake.recordInvocation("OnUpdateDataSubscriptions", []interface{}{arg1, arg2})
	fake.onUpdateDataSubscriptionsMutex.Unlock()
	if stub != nil {
		fake.OnUpdateDataSubscriptionsStub(arg1, arg2)
	}
}

func (fake *FakeLocalParticipantListener) OnUpdateDataSubscriptionsCallCount() int {
	fake.onUpdateDataSubscriptionsMutex.RLock()
	defer fake.onUpdateDataSubscriptionsMutex.RUnlock()
	return len(fake.onUpdateDataSubscriptionsArgsForCall)
}

func (fake *FakeLocalParticipantListener) OnUpdateDataSubscriptionsCalls(stub func(types.LocalParticipant, *livekit.UpdateDataSubscription)) {
	fake.onUpdateDataSubscriptionsMutex.Lock()
	defer fake.onUpdateDataSubscriptionsMutex.Unlock()
	fake.OnUpdateDataSubscriptionsStub = stub
}

func (fake *FakeLocalParticipantListener) OnUpdateDataSubscriptionsArgsForCall(i int) (types.LocalParticipant, *livekit.UpdateDataSubscription) {
	fake.onUpdateDataSubscriptionsMutex.RLock()
	defer fake.onUpdateDataSubscriptionsMutex.RUnlock()
	argsForCall := fake.onUpdateDataSubscriptionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipantListener) OnUpdateSubscriptionPermission(arg1 types.LocalParticipant, arg2 *livekit.SubscriptionPermission) error {
	fake.onUpdateSubscriptionPermissionMutex.Lock()
	ret, specificReturn := fake.onUpdateSubscriptionPermissionReturnsOnCall[len(fake.onUpdateSubscriptionPermissionArgsForCall)]
	fake.onUpdateSubscriptionPermissionArgsForCall = append(fake.onUpdateSubscriptionPermissionArgsForCall, struct {
		arg1 types.LocalParticipant
		arg2 *livekit.SubscriptionPermission
	}{arg1, arg2})
	stub := fake.OnUpdateSubscriptionPermissionStub
	fakeReturns := fake.onUpdateSubscriptionPermissionReturns
	fake.recordInvocation("OnUpdateSubscriptionPermission", []interface{}{arg1, arg2})
	fake.onUpdateSubscriptionPermissionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeLocalParticipantListener) OnUpdateSubscriptionPermissionCallCount() int {
	fake.onUpdateSubscriptionPermissionMutex.RLock()
	defer fake.onUpdateSubscriptionPermissionMutex.RUnlock()
	return len(fake.onUpdateSubscriptionPermissionArgsForCall)
}

func (fake *FakeLocalParticipantListener) OnUpdateSubscriptionPermissionCalls(stub func(types.LocalParticipant, *livekit.SubscriptionPermission) error) {
	fake.onUpdateSubscriptionPermissionMutex.Lock()
	defer fake.onUpdateSubscriptionPermissionMutex.Unlock()
	fake.OnUpdateSubscriptionPermissionStub = stub
}

func (fake *FakeLocalParticipantListener) OnUpdateSubscriptionPermissionArgsForCall(i int) (types.LocalParticipant, *livekit.SubscriptionPermission) {
	fake.onUpdateSubscriptionPermissionMutex.RLock()
	defer fake.onUpdateSubscriptionPermissionMutex.RUnlock()
	argsForCall := fake.onUpdateSubscriptionPermissionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLocalParticipantListener) OnUpdateSubscriptionPermissionReturns(result1 error) {
	fake.onUpdateSubscriptionPermissionMutex.Lock()
	defer fake.onUpdateSubscriptionPermissionMutex.Unlock()
	fake.OnUpdateSubscriptionPermissionStub = nil
	fake.onUpdateSubscriptionPermissionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipantListener) OnUpdateSubscriptionPermissionReturnsOnCall(i int, result1 error) {
	fake.onUpdateSubscriptionPermissionMutex.Lock()
	defer fake.onUpdateSubscriptionPermissionMutex.Unlock()
	fake.OnUpdateSubscriptionPermissionStub = nil
	if fake.onUpdateSubscriptionPermissionReturnsOnCall == nil {
		fake.onUpdateSubscriptionPermissionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.onUpdateSubscriptionPermissionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeLocalParticipantListener) OnUpdateSubscriptions(arg1 types.LocalParticipant, arg2 []livekit.TrackID, arg3 []*livekit.ParticipantTracks, arg4 bool) {
	var arg2Copy []livekit.TrackID
	if arg2 != nil {
		arg2Copy = make([]livekit.TrackID, len(arg2))
		copy(arg2Copy, arg2)
	}
	var arg3Copy []*livekit.ParticipantTracks
	if arg3 != nil {
		arg3Copy = make([]*livekit.ParticipantTracks, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.onUpdateSubscriptionsMutex.Lock()
	fake.onUpdateSubscriptionsArgsForCall = append(fake.onUpdateSubscriptionsArgsForCall, struct {
		arg1 types.LocalParticipant
		arg2 []livekit.TrackID
		arg3 []*livekit.ParticipantTracks
		arg4 bool
	}{arg1, arg2Copy, arg3Copy, arg4})
	stub := fake.OnUpdateSubscriptionsStub
	fake.recordInvocation("OnUpdateSubscriptions", []interface{}{arg1, arg2Copy, arg3Copy, arg4})
	fake.onUpdateSubscriptionsMutex.Unlock()
	if stub != nil {
		fake.OnUpdateSubscriptionsStub(arg1, arg2, arg3, arg4)
	}
}

func (fake *FakeLocalParticipantListener) OnUpdateSubscriptionsCallCount() int {
	fake.onUpdateSubscriptionsMutex.RLock()
	defer fake.onUpdateSubscriptionsMutex.RUnlock()
	return len(fake.onUpdateSubscriptionsArgsForCall)
}

func (fake *FakeLocalParticipantListener) OnUpdateSubscriptionsCalls(stub func(types.LocalParticipant, []livekit.TrackID, []*livekit.ParticipantTracks, bool)) {
	fake.onUpdateSubscriptionsMutex.Lock()
	defer fake.onUpdateSubscriptionsMutex.Unlock()
	fake.OnUpdateSubscriptionsStub = stub
}

func (fake *FakeLocalParticipantListener) OnUpdateSubscriptionsArgsForCall(i int) (types.LocalParticipant, []livekit.TrackID, []*livekit.ParticipantTracks, bool) {
	fake.onUpdateSubscriptionsMutex.RLock()
	defer fake.onUpdateSubscriptionsMutex.RUnlock()
	argsForCall := fake.onUpdateSubscriptionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeLocalParticipantListener) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeLocalParticipantListener) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ types.LocalParticipantListener = new(FakeLocalParticipantListener)
